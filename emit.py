

def write_parser(out, grammar, states, prods, init_state_map):
    out.write("import pgen_runtime\n\n")
    out.write("actions = [\n")
    for i, state in enumerate(states):
        out.write("    # {}. {}\n".format(i, state.traceback() or "<empty>"))
        ##for item in state._lr_items:
        ##    out.write("    #       {}\n".format(grammar.lr_item_to_str(prods, item)))
        out.write("    " + repr(state.action_row) + ",\n")
        out.write("\n")
    out.write("]\n\n")
    out.write("ctns = [\n")
    for state in states:
        out.write("    " + repr(state.ctn_row) + ",\n")
    out.write("]\n\n")

    out.write("reductions = [\n")
    for prod in prods:
        reduce_method_name = '{}_P{}'.format(prod.nt, prod.index)
        names = ["x" + str(i)
                 for i, e in enumerate(prod.rhs)
                 if grammar.is_terminal(e) or grammar.is_nt(e)]
        names_with_none = names[:]
        for i in prod.removals:
            names_with_none.insert(i, "None")
        fn = ("lambda builder, "
              + ", ".join(names)
              + ": builder.{}(".format(reduce_method_name)
              + ", ".join(names_with_none)
              + ")")
        out.write("    ({!r}, {!r}, {}),\n".format(prod.nt, len(names), fn))
    out.write("]\n\n")

    out.write("class DefaultBuilder:\n")
    for prod in prods:
        reduce_method_name = '{}_P{}'.format(prod.nt, prod.index)
        out.write("    def {}(self, *args): return ({!r}, {!r}, list(args))\n"
                  .format(reduce_method_name, prod.nt, prod.index))
    out.write("\n\n")

    for init_nt, index in init_state_map.items():
        out.write("parse_{} = pgen_runtime.make_parse_fn(actions, ctns, reductions, {}, DefaultBuilder)\n"
                  .format(init_nt, index))

TERMINAL_NAMES = {
    "{": "OpenBrace",
    "}": "CloseBrace",
    ";": "Semicolon",
    "?": "QuestionMark",
    "IDENT": "Identifier",
    "STR": "String",
    "=": "EqualSign",
}

def write_rust_parser(out, grammar, states, prods, init_state_map):
    out.write("// THIS FILE IS AUTOGENERATED -- HAHAHAHA\n\n")

    out.write("use super::parser_runtime::{self, Node, ParserTables, TokenStream};\n\n")

    out.write("const ERROR: i64 = {};\n\n".format(hex(ERROR)))

    terminals = list(OrderedSet(t for state in states for t in state.action_row))
    out.write("#[derive(Copy, Clone, Debug, PartialEq)]\n")
    out.write("pub enum TerminalId {\n")
    for i, t in enumerate(terminals):
        if t is None:
            name = "End"
        elif t in TERMINAL_NAMES:
            name = TERMINAL_NAMES[t]
        elif t.isalpha():
            name = t.capitalize()
        else:
            raise ValueError("mysterious token type: " + repr(t))
        out.write("    {} = {}, // {}\n".format(name, i, repr(t)))
    out.write("}\n\n")

    out.write("static ACTIONS: [i64; {}] = [\n".format(len(states) * len(terminals)))
    for i, state in enumerate(states):
        out.write("    // {}. {}\n".format(i, state.traceback() or "<empty>"))
        out.write("    {}\n".format(' '.join("{},".format(state.action_row.get(t, "ERROR"))
                                             for t in terminals)))
        if i < len(states) - 1:
            out.write("\n")
    out.write("];\n\n")

    nonterminals = list(OrderedSet(nt for state in states for nt in state.ctn_row))

    def to_camel_case(id):
        return ''.join(word.capitalize() for word in id.split('_'))

    seen = {}
    for nt in nonterminals:
        cc = to_camel_case(nt)
        if cc in seen:
            raise ValueError("{} and {} have the same camel-case spelling ({})".format(
                seen[cc], nt, cc))
        seen[cc] = nt

    def nt_node_variant(grammar, prod):
        name = to_camel_case(prod.nt)
        if len(grammar.nonterminals[prod.nt]) > 1:
            name += "P" + str(prod.index)
        return name

    seen = {}
    for prod in prods:
        if prod.nt in nonterminals and not prod.removals:
            name = nt_node_variant(grammar, prod)
            if name in seen:
                raise ValueError("Productions {} and {} have the same spelling ({})".format(
                    grammar.production_to_str(seen[name].nt, seen[name].rhs),
                    grammar.production_to_str(prod.nt, prod.rhs),
                    name))
            seen[name] = prod

    prod_optional_element_indexes = {
        (prod.nt, prod.index): set(
            i
            for p in prods
            if p.nt == prod.nt and p.index == prod.index
            for i in p.removals
        )
        for prod in prods
        if prod.nt in nonterminals and not prod.removals
    }

    # Reverse-engineered original productions for everything
    originals = {
        (prod.nt, prod.index): [
            (Optional(e) if i in prod_optional_element_indexes[prod.nt, prod.index] else e)
            for i, e in enumerate(prod.rhs)
        ]
        for prod in prods
        if prod.nt in nonterminals and not prod.removals
    }

    def rust_type_of_element(prod, i, e):
        if grammar.is_variable_terminal(e):
            ty = 'Node'
        elif grammar.is_terminal(e):
            ty = '()'
        else:
            assert grammar.is_nt(e)
            ty = 'Node'

        if i in prod_optional_element_indexes[(prod.nt, prod.index)]:
            if ty == '()':
                ty = 'bool'
            else:
                ty = 'Option<{}>'.format(ty)
        return ty

    out.write("#[derive(Debug)]\n")
    out.write("pub enum NtNode {\n")
    for prod in prods:
        # Each production with an optional element removed uses the same
        # variant as the corresponding production where the optional element is
        # present.
        if prod.nt in nonterminals and not prod.removals:
            types = []
            for i, e in enumerate(prod.rhs):
                ty = rust_type_of_element(prod, i, e)
                if ty != '()':
                    types.append(ty)

            out.write("    // {}\n".format(grammar.production_to_str(prod.nt, prod.rhs)))
            name = nt_node_variant(grammar, prod)
            out.write("    {}({}),\n".format(name, ", ".join(types)))
    out.write("}\n\n")

    out.write("#[derive(Clone, Copy, Debug, PartialEq)]\n")
    out.write("pub enum NonterminalId {\n")
    for i, nt in enumerate(nonterminals):
        out.write("    {} = {},\n".format(to_camel_case(nt), i))
    out.write("}\n\n")

    out.write("static GOTO: [usize; {}] = [\n".format(len(states) * len(nonterminals)))
    for state in states:
        row = state.ctn_row
        out.write("    {}\n".format(' '.join("{},".format(row.get(nt, 0)) for nt in nonterminals)))
    out.write("];\n\n")

    out.write("fn reduce(prod: usize, stack: &mut Vec<Node>) -> NonterminalId {\n")
    out.write("    match prod {\n")
    for i, prod in enumerate(prods):
        # If prod.nt is not in nonterminals, that means it's a goal
        # nonterminal, only accepted, never reduced.
        if prod.nt in nonterminals:
            out.write("        {} => {{\n".format(i))
            out.write("            // {}\n".format(grammar.production_to_str(prod.nt, prod.rhs)))

            stack_elements = []  # to remove
            arguments = []       # to pass to constructor
            original_index = 0
            variable_index = 0
            for element in prod.rhs:
                while original_index in prod.removals:
                    e = originals[prod.nt, prod.index][original_index]
                    assert isinstance(e, Optional)
                    if rust_type_of_element(prod, original_index, e.inner) == 'bool':
                        arg = "false"
                    else:
                        arg = "None"
                    arguments.append(arg)
                    original_index += 1

                ty = rust_type_of_element(prod, original_index, element)
                if ty == '()':
                    var = None
                    arg = '()'
                elif ty == 'bool':
                    var = None
                    arg = 'true'
                else:
                    var = "x" + str(variable_index)
                    variable_index += 1
                    arg = var
                if ty.startswith('Option<'):
                    arg = "Some({})".format(arg)

                stack_elements.append(var)
                if ty != '()':
                    arguments.append(arg)
                original_index += 1

            for var in reversed(stack_elements):
                if var is None:
                    out.write("            stack.pop();\n")
                else:
                    out.write("            let {} = stack.pop().unwrap();\n".format(var))

            ntv = nt_node_variant(grammar, prod)
            out.write("            stack.push(Node::Nonterminal(Box::new(NtNode::{}({}))));\n".format(
                ntv,
                ", ".join(arguments)
            ))
            out.write("            NonterminalId::{}\n".format(to_camel_case(prod.nt)))
            out.write("        }\n")
    out.write('        _ => panic!("no such production: {}", prod),\n')
    out.write("    }\n")
    out.write("}\n\n")

    out.write(
        "static TABLES: ParserTables<'static> = ParserTables {\n" +
        "    state_count: {},\n".format(len(states)) +
        "    action_table: &ACTIONS,\n" +
        "    action_width: {},\n".format(len(terminals)) +
        "    goto_table: &GOTO,\n" +
        "    goto_width: {},\n".format(len(nonterminals)) +
        "};\n\n"
    )

    for init_nt, index in init_state_map.items():
        out.write("pub fn parse_{}<In: TokenStream<Token=crate::ast::Token>>(\n".format(init_nt))
        out.write("    tokens: In,\n")
        out.write(") -> Result<Node, &'static str> {\n")
        out.write("    parser_runtime::parse(tokens, {}, &TABLES, reduce)\n".format(index))
        out.write("}\n\n")


