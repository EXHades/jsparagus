
StringNumericLiteral :::
  StrWhiteSpace?
  StrWhiteSpace? StrNumericLiteral StrWhiteSpace?

StrWhiteSpace :::
  StrWhiteSpaceChar StrWhiteSpace?

StrWhiteSpaceChar :::
  WhiteSpace
  LineTerminator

StrNumericLiteral :::
  StrDecimalLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral

StrDecimalLiteral :::
  StrUnsignedDecimalLiteral
  `+` StrUnsignedDecimalLiteral
  `-` StrUnsignedDecimalLiteral

StrUnsignedDecimalLiteral :::
  `Infinity`
  DecimalDigits `.` DecimalDigits? ExponentPart?
  `.` DecimalDigits ExponentPart?
  DecimalDigits ExponentPart?


SourceCharacter ::
  `TODO`


InputElementDiv ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  RightBracePunctuator

InputElementRegExp ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RightBracePunctuator
  RegularExpressionLiteral

InputElementRegExpOrTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  RegularExpressionLiteral
  TemplateSubstitutionTail

InputElementTemplateTail ::
  WhiteSpace
  LineTerminator
  Comment
  CommonToken
  DivPunctuator
  TemplateSubstitutionTail


WhiteSpace ::
  <TAB>
  <VT>
  <FF>
  <SP>
  <NBSP>
  <ZWNBSP>
  <USP>


LineTerminator ::
  <LF>
  <CR>
  <LS>
  <PS>

LineTerminatorSequence ::
  <LF>
  <CR> [lookahead != <LF> ]
  <LS>
  <PS>
  <CR> <LF>


Comment ::
  MultiLineComment
  SingleLineComment

MultiLineComment ::
  `/*` MultiLineCommentChars? `*/`

MultiLineCommentChars ::
  MultiLineNotAsteriskChar MultiLineCommentChars?
  `*` PostAsteriskCommentChars?

PostAsteriskCommentChars ::
  MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars?
  `*` PostAsteriskCommentChars?

MultiLineNotAsteriskChar ::
  SourceCharacter but not `*`

MultiLineNotForwardSlashOrAsteriskChar ::
  SourceCharacter but not one of `/` or `*`

SingleLineComment ::
  `//` SingleLineCommentChars?

SingleLineCommentChars ::
  SingleLineCommentChar SingleLineCommentChars?

SingleLineCommentChar ::
  SourceCharacter but not LineTerminator


CommonToken ::
  IdentifierName
  Punctuator
  NumericLiteral
  StringLiteral
  Template


IdentifierName ::
  IdentifierStart
  IdentifierName IdentifierPart

IdentifierStart ::
  UnicodeIDStart
  `$`
  `_`
  `\` UnicodeEscapeSequence

IdentifierPart ::
  UnicodeIDContinue
  `$`
  `\` UnicodeEscapeSequence
  <ZWNJ>
  <ZWJ>

UnicodeIDStart ::
  `TODO`

UnicodeIDContinue ::
  `TODO`


ReservedWord ::
  Keyword
  FutureReservedWord
  NullLiteral
  BooleanLiteral


Keyword :: one of
  `await`
  `break`
  `case` `catch` `class` `const` `continue`
  `debugger` `default` `delete` `do`
  `else` `export` `extends`
  `finally` `for` `function`
  `if` `import` `in` `instanceof`
  `new`
  `return`
  `super` `switch`
  `this` `throw` `try` `typeof`
  `var` `void`
  `while` `with`
  `yield`


FutureReservedWord ::
  `enum`


Punctuator :: one of
  `{` `(` `)` `[` `]`
  `.` `...` `;` `,`
  `<` `>` `<=` `>=`
  `==` `!=` `===` `!==`
  `+` `-` `*` `%` `**`
  `++` `--`
  `<<` `>>` `>>>`
  `&` `|` `^`
  `!` `~`
  `&&` `||`
  `?` `:`
  `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=`
  `=>`

DivPunctuator ::
  `/`
  `/=`

RightBracePunctuator ::
  `}`


NullLiteral ::
  `null`


BooleanLiteral ::
  `true`
  `false`


NumericLiteral ::
  DecimalLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral

DecimalLiteral ::
  DecimalIntegerLiteral `.` DecimalDigits? ExponentPart?
  `.` DecimalDigits ExponentPart?
  DecimalIntegerLiteral ExponentPart?

DecimalIntegerLiteral ::
  `0`
  NonZeroDigit DecimalDigits?

DecimalDigits ::
  DecimalDigit
  DecimalDigits DecimalDigit

DecimalDigit :: one of
  `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`

NonZeroDigit :: one of
  `1` `2` `3` `4` `5` `6` `7` `8` `9`

ExponentPart ::
  ExponentIndicator SignedInteger

ExponentIndicator :: one of
  `e` `E`

SignedInteger ::
  DecimalDigits
  `+` DecimalDigits
  `-` DecimalDigits

BinaryIntegerLiteral ::
  `0b` BinaryDigits
  `0B` BinaryDigits

BinaryDigits ::
  BinaryDigit
  BinaryDigits BinaryDigit

BinaryDigit :: one of
  `0` `1`

OctalIntegerLiteral ::
  `0o` OctalDigits
  `0O` OctalDigits

OctalDigits ::
  OctalDigit
  OctalDigits OctalDigit

OctalDigit :: one of
  `0` `1` `2` `3` `4` `5` `6` `7`

HexIntegerLiteral ::
  `0x` HexDigits
  `0X` HexDigits

HexDigits ::
  HexDigit
  HexDigits HexDigit

HexDigit :: one of
  `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`


StringLiteral ::
  `"` DoubleStringCharacters? `"`
  `'` SingleStringCharacters? `'`

DoubleStringCharacters ::
  DoubleStringCharacter DoubleStringCharacters?

SingleStringCharacters ::
  SingleStringCharacter SingleStringCharacters?

DoubleStringCharacter ::
  SourceCharacter but not one of `"` or `\` or LineTerminator
  `\` EscapeSequence
  LineContinuation

SingleStringCharacter ::
  SourceCharacter but not one of `'` or `\` or LineTerminator
  `\` EscapeSequence
  LineContinuation

LineContinuation ::
  `\` LineTerminatorSequence

EscapeSequence ::
  CharacterEscapeSequence
  `0` [lookahead <! DecimalDigit]
  HexEscapeSequence
  UnicodeEscapeSequence


CharacterEscapeSequence ::
  SingleEscapeCharacter
  NonEscapeCharacter

SingleEscapeCharacter :: one of
  `'` `"` `\` `b` `f` `n` `r` `t` `v`

NonEscapeCharacter ::
  SourceCharacter but not one of EscapeCharacter or LineTerminator

EscapeCharacter ::
  SingleEscapeCharacter
  DecimalDigit
  `x`
  `u`

HexEscapeSequence ::
  `x` HexDigit HexDigit

UnicodeEscapeSequence ::
  `u` Hex4Digits
  `u{` CodePoint `}`

Hex4Digits ::
  HexDigit HexDigit HexDigit HexDigit


RegularExpressionLiteral ::
  `/` RegularExpressionBody `/` RegularExpressionFlags

RegularExpressionBody ::
  RegularExpressionFirstChar RegularExpressionChars

RegularExpressionChars ::
  [empty]
  RegularExpressionChars RegularExpressionChar

RegularExpressionFirstChar ::
  RegularExpressionNonTerminator but not one of `*` or `\` or `/` or `[`
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionChar ::
  RegularExpressionNonTerminator but not one of `\` or `/` or `[`
  RegularExpressionBackslashSequence
  RegularExpressionClass

RegularExpressionBackslashSequence ::
  `\` RegularExpressionNonTerminator

RegularExpressionNonTerminator ::
  SourceCharacter but not LineTerminator

RegularExpressionClass ::
  `[` RegularExpressionClassChars `]`

RegularExpressionClassChars ::
  [empty]
  RegularExpressionClassChars RegularExpressionClassChar

RegularExpressionClassChar ::
  RegularExpressionNonTerminator but not one of `]` or `\`
  RegularExpressionBackslashSequence

RegularExpressionFlags ::
  [empty]
  RegularExpressionFlags IdentifierPart


Template ::
  NoSubstitutionTemplate
  TemplateHead

NoSubstitutionTemplate ::
  ``` TemplateCharacters? ```

TemplateHead ::
  ``` TemplateCharacters? `${`

TemplateSubstitutionTail ::
  TemplateMiddle
  TemplateTail

TemplateMiddle ::
  `}` TemplateCharacters? `${`

TemplateTail ::
  `}` TemplateCharacters? ```

TemplateCharacters ::
  TemplateCharacter TemplateCharacters?

TemplateCharacter ::
  `$` [lookahead != `{` ]
  `\` EscapeSequence
  `\` NotEscapeSequence
  LineContinuation
  LineTerminatorSequence
  SourceCharacter but not one of ``` or `\` or `$` or LineTerminator

NotEscapeSequence ::
  `0` DecimalDigit
  DecimalDigit but not `0`
  `x` [lookahead <! HexDigit]
  `x` HexDigit [lookahead <! HexDigit]
  `u` [lookahead <! HexDigit] [lookahead != `{`]
  `u` HexDigit [lookahead <! HexDigit]
  `u` HexDigit HexDigit [lookahead <! HexDigit]
  `u` HexDigit HexDigit HexDigit [lookahead <! HexDigit]
  `u` `{` [lookahead <! HexDigit]
  `u` `{` NotCodePoint [lookahead <! HexDigit]
  `u` `{` CodePoint [lookahead <! HexDigit] [lookahead != `}`]

NotCodePoint ::
  HexDigits [> but only if MV of HexDigits > 0x10FFFF ]

CodePoint ::
  HexDigits [> but only if MV of HexDigits â‰¤ 0x10FFFF ]


IdentifierReference[Yield, Await] :
  Identifier

BindingIdentifier[Yield, Await] :
  Identifier
  `yield`
  `await`

LabelIdentifier[Yield, Await] :
  Identifier

PrimaryExpression[Yield, Await] :
  `this`
    => this_expr()
  IdentifierReference[?Yield, ?Await]
    => identifier_expr($0)
  Literal
    => $0
  ArrayLiteral[?Yield, ?Await]
    => $0
  ObjectLiteral[?Yield, ?Await]
    => $0
  FunctionExpression
    => $0
  ClassExpression[?Yield, ?Await]
    => $0
  GeneratorExpression
    => $0
  AsyncFunctionExpression
    => $0
  AsyncGeneratorExpression
    => $0
  RegularExpressionLiteral
    => regexp_literal($0)
  TemplateLiteral[?Yield, ?Await, ~Tagged]
    => untagged_template_expr($0)
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
    => parenthesized_expr($0)

CoverParenthesizedExpressionAndArrowParameterList[Yield, Await] :
  `(` Expression[+In, ?Yield, ?Await] `)`
  `(` Expression[+In, ?Yield, ?Await] `,` `)`
  `(` `)`
  `(` `...` BindingIdentifier[?Yield, ?Await] `)`
  `(` `...` BindingPattern[?Yield, ?Await] `)`
  `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingIdentifier[?Yield, ?Await] `)`
  `(` Expression[+In, ?Yield, ?Await] `,` `...` BindingPattern[?Yield, ?Await] `)`


ParenthesizedExpression[Yield, Await] :
  `(` Expression[+In, ?Yield, ?Await] `)`


Literal :
  NullLiteral
    => null_literal()
  BooleanLiteral
    => boolean_literal($0)
  NumericLiteral
    => numeric_literal($0)
  StringLiteral
    => string_literal($0)


ArrayLiteral[Yield, Await] :
  `[` Elision? `]`
    => array_literal_empty($1)
  `[` ElementList[?Yield, ?Await] `]`
    => array_literal($1)
  `[` ElementList[?Yield, ?Await] `,` Elision? `]`
    => array_literal_with_trailing_elision($1, $3)

ElementList[Yield, Await] :
  Elision? AssignmentExpression[+In, ?Yield, ?Await]
    => element_list_first($0, $1)
  Elision? SpreadElement[?Yield, ?Await]
    => element_list_first_spread($0, $1)
  ElementList[?Yield, ?Await] `,` Elision? AssignmentExpression[+In, ?Yield, ?Await]
    => element_list_append($0, $2, $3)
  ElementList[?Yield, ?Await] `,` Elision? SpreadElement[?Yield, ?Await]
    => element_list_append_spread($0, $2, $3)

Elision :
  `,`
    => elision_single()
  Elision `,`
    => elision_append($0)

SpreadElement[Yield, Await] :
  `...` AssignmentExpression[+In, ?Yield, ?Await]
    => spread_element($1)


ObjectLiteral[Yield, Await] :
  `{` `}`
    => object_literal_empty()
  `{` PropertyDefinitionList[?Yield, ?Await] `}`
    => object_literal($1)
  `{` PropertyDefinitionList[?Yield, ?Await] `,` `}`
    => object_literal($1)

PropertyDefinitionList[Yield, Await] :
  PropertyDefinition[?Yield, ?Await]
    => property_definition_list_single($0)
  PropertyDefinitionList[?Yield, ?Await] `,` PropertyDefinition[?Yield, ?Await]
    => property_definition_list_append($0, $2)

PropertyDefinition[Yield, Await] :
  IdentifierReference[?Yield, ?Await]
  CoverInitializedName[?Yield, ?Await]
  PropertyName[?Yield, ?Await] `:` AssignmentExpression[+In, ?Yield, ?Await]
  MethodDefinition[?Yield, ?Await]
  `...` AssignmentExpression[+In, ?Yield, ?Await]

PropertyName[Yield, Await] :
  LiteralPropertyName
  ComputedPropertyName[?Yield, ?Await]

LiteralPropertyName :
  IdentifierName
  StringLiteral
  NumericLiteral

ComputedPropertyName[Yield, Await] :
  `[` AssignmentExpression[+In, ?Yield, ?Await] `]`

CoverInitializedName[Yield, Await] :
  IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]

Initializer[In, Yield, Await] :
  `=` AssignmentExpression[?In, ?Yield, ?Await] => $1


TemplateLiteral[Yield, Await, Tagged] :
  NoSubstitutionTemplate
  SubstitutionTemplate[?Yield, ?Await, ?Tagged]

SubstitutionTemplate[Yield, Await, Tagged] :
  TemplateHead Expression[+In, ?Yield, ?Await] TemplateSpans[?Yield, ?Await, ?Tagged]

TemplateSpans[Yield, Await, Tagged] :
  TemplateTail
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateTail

TemplateMiddleList[Yield, Await, Tagged] :
  TemplateMiddle Expression[+In, ?Yield, ?Await]
  TemplateMiddleList[?Yield, ?Await, ?Tagged] TemplateMiddle Expression[+In, ?Yield, ?Await]


MemberExpression[Yield, Await] :
  PrimaryExpression[?Yield, ?Await]
    => $0
  MemberExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
    => computed_member_expr($0, $2)
  MemberExpression[?Yield, ?Await] `.` IdentifierName
    => static_member_expr($0, $2)
  MemberExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
    => tagged_template_expr($0, $1)
  SuperProperty[?Yield, ?Await]
    => $0
  MetaProperty
    => $0
  `new` MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    => new_expr_with_arguments($1, $2)

SuperProperty[Yield, Await] :
  `super` `[` Expression[+In, ?Yield, ?Await] `]`
    => super_property_computed($2)
  `super` `.` IdentifierName
    => super_property_static($2)

MetaProperty :
  NewTarget => $0

NewTarget :
  `new` `.` `target`
    => new_target_expr()

NewExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await]
    => $0
  `new` NewExpression[?Yield, ?Await]
    => new_expr_without_arguments($1)

CallExpression[Yield, Await] :
  CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await]
    => $0
  SuperCall[?Yield, ?Await]
    => $0
  CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    => call_expr($0, $1)
  CallExpression[?Yield, ?Await] `[` Expression[+In, ?Yield, ?Await] `]`
    => computed_member_expr($0, $2)
  CallExpression[?Yield, ?Await] `.` IdentifierName
    => static_member_expr($0, $2)
  CallExpression[?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]
    => tagged_template_expr($0, $1)

SuperCall[Yield, Await] :
  `super` Arguments[?Yield, ?Await]
    => super_call($1)

Arguments[Yield, Await] :
  `(` `)`
    => arguments_empty()
  `(` ArgumentList[?Yield, ?Await] `)`
    => $1
  `(` ArgumentList[?Yield, ?Await] `,` `)`
    => $1

ArgumentList[Yield, Await] :
  AssignmentExpression[+In, ?Yield, ?Await]
    => arguments_append(arguments_empty(), $0)
  `...` AssignmentExpression[+In, ?Yield, ?Await]
    => arguments_append_spread(arguments_empty(), $1)
  ArgumentList[?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await]
    => arguments_append($0, $2)
  ArgumentList[?Yield, ?Await] `,` `...` AssignmentExpression[+In, ?Yield, ?Await]
    => arguments_append_spread($0, $3)

LeftHandSideExpression[Yield, Await] :
  NewExpression[?Yield, ?Await] => $0
  CallExpression[?Yield, ?Await] => $0


CallMemberExpression[Yield, Await] :
  MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    => call_expr($0, $1)


UpdateExpression[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]
    => $0
  LeftHandSideExpression[?Yield, ?Await] `++`
    => post_increment_expr($0)
  LeftHandSideExpression[?Yield, ?Await] `--`
    => post_decrement_expr($0)
  `++` UnaryExpression[?Yield, ?Await]
    => pre_decrement_expr($1)
  `--` UnaryExpression[?Yield, ?Await]
    => pre_decrement_expr($1)


UnaryExpression[Yield, Await] :
  UpdateExpression[?Yield, ?Await]
    => $0
  `delete` UnaryExpression[?Yield, ?Await]
    => delete_expr($1)
  `void` UnaryExpression[?Yield, ?Await]
    => void_expr($1)
  `typeof` UnaryExpression[?Yield, ?Await]
    => typeof_expr($1)
  `+` UnaryExpression[?Yield, ?Await]
    => unary_plus_expr($1)
  `-` UnaryExpression[?Yield, ?Await]
    => unary_minus_expr($1)
  `~` UnaryExpression[?Yield, ?Await]
    => bitwise_not_expr($1)
  `!` UnaryExpression[?Yield, ?Await]
    => logical_not_expr($1)
  [+Await] AwaitExpression[?Yield]
    => $0


ExponentiationExpression[Yield, Await] :
  UnaryExpression[?Yield, ?Await]
  UpdateExpression[?Yield, ?Await] `**` ExponentiationExpression[?Yield, ?Await]
    => binary_expr(pow_op(), $0, $2)


MultiplicativeExpression[Yield, Await] :
  ExponentiationExpression[?Yield, ?Await]
  MultiplicativeExpression[?Yield, ?Await] MultiplicativeOperator ExponentiationExpression[?Yield, ?Await]
    => multiplicative_expr($0, $1, $2)

MultiplicativeOperator :
  `*`
    => box_op(mul_op())
  `/`
    => box_op(div_op())
  `%`
    => box_op(mod_op())


AdditiveExpression[Yield, Await] :
  MultiplicativeExpression[?Yield, ?Await]
  AdditiveExpression[?Yield, ?Await] `+` MultiplicativeExpression[?Yield, ?Await]
    => binary_expr(add_op(), $0, $2)
  AdditiveExpression[?Yield, ?Await] `-` MultiplicativeExpression[?Yield, ?Await]
    => binary_expr(sub_op(), $0, $2)


ShiftExpression[Yield, Await] :
  AdditiveExpression[?Yield, ?Await]
  ShiftExpression[?Yield, ?Await] `<<` AdditiveExpression[?Yield, ?Await]
    => binary_expr(left_shift_op(), $0, $2)
  ShiftExpression[?Yield, ?Await] `>>` AdditiveExpression[?Yield, ?Await]
    => binary_expr(right_shift_op(), $0, $2)
  ShiftExpression[?Yield, ?Await] `>>>` AdditiveExpression[?Yield, ?Await]
    => binary_expr(right_shift_ext_op(), $0, $2)


RelationalExpression[In, Yield, Await] :
  ShiftExpression[?Yield, ?Await]
  RelationalExpression[?In, ?Yield, ?Await] `<` ShiftExpression[?Yield, ?Await]
    => binary_expr(less_than_op(), $0, $2)
  RelationalExpression[?In, ?Yield, ?Await] `>` ShiftExpression[?Yield, ?Await]
    => binary_expr(greater_than_op(), $0, $2)
  RelationalExpression[?In, ?Yield, ?Await] `<=` ShiftExpression[?Yield, ?Await]
    => binary_expr(less_than_or_equal_op(), $0, $2)
  RelationalExpression[?In, ?Yield, ?Await] `>=` ShiftExpression[?Yield, ?Await]
    => binary_expr(greater_than_or_equal_op(), $0, $2)
  RelationalExpression[?In, ?Yield, ?Await] `instanceof` ShiftExpression[?Yield, ?Await]
    => binary_expr(instanceof_op(), $0, $2)
  [+In] RelationalExpression[+In, ?Yield, ?Await] `in` ShiftExpression[?Yield, ?Await]
    => binary_expr(in_op(), $0, $2)


EqualityExpression[In, Yield, Await] :
  RelationalExpression[?In, ?Yield, ?Await]
  EqualityExpression[?In, ?Yield, ?Await] `==` RelationalExpression[?In, ?Yield, ?Await]
    => binary_expr(equals_op(), $0, $2)
  EqualityExpression[?In, ?Yield, ?Await] `!=` RelationalExpression[?In, ?Yield, ?Await]
    => binary_expr(not_equals_op(), $0, $2)
  EqualityExpression[?In, ?Yield, ?Await] `===` RelationalExpression[?In, ?Yield, ?Await]
    => binary_expr(strict_equals_op(), $0, $2)
  EqualityExpression[?In, ?Yield, ?Await] `!==` RelationalExpression[?In, ?Yield, ?Await]
    => binary_expr(strict_not_equals_op(), $0, $2)


BitwiseANDExpression[In, Yield, Await] :
  EqualityExpression[?In, ?Yield, ?Await]
  BitwiseANDExpression[?In, ?Yield, ?Await] `&` EqualityExpression[?In, ?Yield, ?Await]
    => binary_expr(bitwise_and_op(), $0, $2)

BitwiseXORExpression[In, Yield, Await] :
  BitwiseANDExpression[?In, ?Yield, ?Await]
  BitwiseXORExpression[?In, ?Yield, ?Await] `^` BitwiseANDExpression[?In, ?Yield, ?Await]
    => binary_expr(bitwise_xor_op(), $0, $2)

BitwiseORExpression[In, Yield, Await] :
  BitwiseXORExpression[?In, ?Yield, ?Await]
  BitwiseORExpression[?In, ?Yield, ?Await] `|` BitwiseXORExpression[?In, ?Yield, ?Await]
    => binary_expr(bitwise_or_op(), $0, $2)


LogicalANDExpression[In, Yield, Await] :
  BitwiseORExpression[?In, ?Yield, ?Await]
  LogicalANDExpression[?In, ?Yield, ?Await] `&&` BitwiseORExpression[?In, ?Yield, ?Await]
    => binary_expr(logical_and_op(), $0, $2)

LogicalORExpression[In, Yield, Await] :
  LogicalANDExpression[?In, ?Yield, ?Await]
  LogicalORExpression[?In, ?Yield, ?Await] `||` LogicalANDExpression[?In, ?Yield, ?Await]
    => binary_expr(logical_or_op(), $0, $2)


ConditionalExpression[In, Yield, Await] :
  LogicalORExpression[?In, ?Yield, ?Await]
  LogicalORExpression[?In, ?Yield, ?Await] `?` AssignmentExpression[+In, ?Yield, ?Await] `:` AssignmentExpression[?In, ?Yield, ?Await]
    => conditional_expr($0, $2, $4)


AssignmentExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
    => $0
  [+Yield] YieldExpression[?In, ?Await]
    => $0
  ArrowFunction[?In, ?Yield, ?Await]
    => $0
  AsyncArrowFunction[?In, ?Yield, ?Await]
    => $0
  LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await]
    => assignment_expr($0, $2)
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
    => compound_assignment_expr($0, $1, $2)

AssignmentOperator :
  `*=`
    => box_assign_op(mul_assign_op())
  `/=`
    => box_assign_op(div_assign_op())
  `%=`
    => box_assign_op(mod_assign_op())
  `+=`
    => box_assign_op(add_assign_op())
  `-=`
    => box_assign_op(sub_assign_op())
  `<<=`
    => box_assign_op(left_shift_assign_op())
  `>>=`
    => box_assign_op(right_shift_assign_op())
  `>>>=`
    => box_assign_op(right_shift_ext_assign_op())
  `&=`
    => box_assign_op(bitwise_and_assign_op())
  `^=`
    => box_assign_op(bitwise_xor_assign_op())
  `|=`
    => box_assign_op(bitwise_or_assign_op())
  `**=`
    => box_assign_op(pow_assign_op())


AssignmentPattern[Yield, Await] :
  ObjectAssignmentPattern[?Yield, ?Await]
  ArrayAssignmentPattern[?Yield, ?Await]

ObjectAssignmentPattern[Yield, Await] :
  `{` `}`
  `{` AssignmentRestProperty[?Yield, ?Await] `}`
  `{` AssignmentPropertyList[?Yield, ?Await] `}`
  `{` AssignmentPropertyList[?Yield, ?Await] `,` AssignmentRestProperty[?Yield, ?Await]? `}`

ArrayAssignmentPattern[Yield, Await] :
  `[` Elision? AssignmentRestElement[?Yield, ?Await]? `]`
  `[` AssignmentElementList[?Yield, ?Await] `]`
  `[` AssignmentElementList[?Yield, ?Await] `,` Elision? AssignmentRestElement[?Yield, ?Await]? `]`

AssignmentRestProperty[Yield, Await] :
  `...` DestructuringAssignmentTarget[?Yield, ?Await]

AssignmentPropertyList[Yield, Await] :
  AssignmentProperty[?Yield, ?Await]
  AssignmentPropertyList[?Yield, ?Await] `,` AssignmentProperty[?Yield, ?Await]

AssignmentElementList[Yield, Await] :
  AssignmentElisionElement[?Yield, ?Await]
  AssignmentElementList[?Yield, ?Await] `,` AssignmentElisionElement[?Yield, ?Await]

AssignmentElisionElement[Yield, Await] :
  Elision? AssignmentElement[?Yield, ?Await]

AssignmentProperty[Yield, Await] :
  IdentifierReference[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?
  PropertyName[?Yield, ?Await] `:` AssignmentElement[?Yield, ?Await]

AssignmentElement[Yield, Await] :
  DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

AssignmentRestElement[Yield, Await] :
  `...` DestructuringAssignmentTarget[?Yield, ?Await]

DestructuringAssignmentTarget[Yield, Await] :
  LeftHandSideExpression[?Yield, ?Await]


Expression[In, Yield, Await] :
  AssignmentExpression[?In, ?Yield, ?Await]
  Expression[?In, ?Yield, ?Await] `,` AssignmentExpression[?In, ?Yield, ?Await]
    => binary_expr(comma_op(), $0, $2)


Statement[Yield, Await, Return] :
  BlockStatement[?Yield, ?Await, ?Return]
  VariableStatement[?Yield, ?Await]
  EmptyStatement
  ExpressionStatement[?Yield, ?Await]
  IfStatement[?Yield, ?Await, ?Return]
  BreakableStatement[?Yield, ?Await, ?Return]
  ContinueStatement[?Yield, ?Await]
  BreakStatement[?Yield, ?Await]
  [+Return] ReturnStatement[?Yield, ?Await]
  WithStatement[?Yield, ?Await, ?Return]
  LabelledStatement[?Yield, ?Await, ?Return]
  ThrowStatement[?Yield, ?Await]
  TryStatement[?Yield, ?Await, ?Return]
  DebuggerStatement

Declaration[Yield, Await] :
  HoistableDeclaration[?Yield, ?Await, ~Default]
  ClassDeclaration[?Yield, ?Await, ~Default]
  LexicalDeclaration[+In, ?Yield, ?Await]

HoistableDeclaration[Yield, Await, Default] :
  FunctionDeclaration[?Yield, ?Await, ?Default]
  GeneratorDeclaration[?Yield, ?Await, ?Default]
  AsyncFunctionDeclaration[?Yield, ?Await, ?Default]
  AsyncGeneratorDeclaration[?Yield, ?Await, ?Default]

BreakableStatement[Yield, Await, Return] :
  IterationStatement[?Yield, ?Await, ?Return]
  SwitchStatement[?Yield, ?Await, ?Return]


BlockStatement[Yield, Await, Return] :
  Block[?Yield, ?Await, ?Return]

Block[Yield, Await, Return] :
  `{` StatementList[?Yield, ?Await, ?Return]? `}`

StatementList[Yield, Await, Return] :
  StatementListItem[?Yield, ?Await, ?Return]
  StatementList[?Yield, ?Await, ?Return] StatementListItem[?Yield, ?Await, ?Return]

StatementListItem[Yield, Await, Return] :
  Statement[?Yield, ?Await, ?Return]
  Declaration[?Yield, ?Await]


LexicalDeclaration[In, Yield, Await] :
  LetOrConst BindingList[?In, ?Yield, ?Await] `;`

ForLexicalDeclaration[In, Yield, Await] :
  LetOrConst BindingList[?In, ?Yield, ?Await] `;`
    => for_lexical_declaration($0, $1)

LetOrConst :
  `let`
    => let_kind()
  `const`
    => const_kind()

BindingList[In, Yield, Await] :
  LexicalBinding[?In, ?Yield, ?Await]
    => variable_declaration_list_single($0)
  BindingList[?In, ?Yield, ?Await] `,` LexicalBinding[?In, ?Yield, ?Await]
    => variable_declaration_list_append($0, $2)

LexicalBinding[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
    => variable_declaration(binding_identifier($0), $1)
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
    => variable_declaration(binding_pattern($0), Some($1))


VariableStatement[Yield, Await] :
  `var` VariableDeclarationList[+In, ?Yield, ?Await] `;`
    => variable_statement($1)

VariableDeclarationList[In, Yield, Await] :
  VariableDeclaration[?In, ?Yield, ?Await]
    => variable_declaration_list_single($0)
  VariableDeclarationList[?In, ?Yield, ?Await] `,` VariableDeclaration[?In, ?Yield, ?Await]
    => variable_declaration_list_append($0, $2)

VariableDeclaration[In, Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]?
    => variable_declaration(binding_identifier($0), $1)
  BindingPattern[?Yield, ?Await] Initializer[?In, ?Yield, ?Await]
    => variable_declaration(binding_pattern($0), Some($1))


BindingPattern[Yield, Await] :
  ObjectBindingPattern[?Yield, ?Await] => $0
  ArrayBindingPattern[?Yield, ?Await] => $0

ObjectBindingPattern[Yield, Await] :
  `{` `}`
  `{` BindingRestProperty[?Yield, ?Await] `}`
  `{` BindingPropertyList[?Yield, ?Await] `}`
  `{` BindingPropertyList[?Yield, ?Await] `,` BindingRestProperty[?Yield, ?Await]? `}`

ArrayBindingPattern[Yield, Await] :
  `[` Elision? BindingRestElement[?Yield, ?Await]? `]`
  `[` BindingElementList[?Yield, ?Await] `]`
  `[` BindingElementList[?Yield, ?Await] `,` Elision? BindingRestElement[?Yield, ?Await]? `]`

BindingRestProperty[Yield, Await] :
  `...` BindingIdentifier[?Yield, ?Await]

BindingPropertyList[Yield, Await] :
  BindingProperty[?Yield, ?Await]
  BindingPropertyList[?Yield, ?Await] `,` BindingProperty[?Yield, ?Await]

BindingElementList[Yield, Await] :
  BindingElisionElement[?Yield, ?Await]
  BindingElementList[?Yield, ?Await] `,` BindingElisionElement[?Yield, ?Await]

BindingElisionElement[Yield, Await] :
  Elision? BindingElement[?Yield, ?Await]

BindingProperty[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  PropertyName[?Yield, ?Await] `:` BindingElement[?Yield, ?Await]

BindingElement[Yield, Await] :
  SingleNameBinding[?Yield, ?Await]
  BindingPattern[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

SingleNameBinding[Yield, Await] :
  BindingIdentifier[?Yield, ?Await] Initializer[+In, ?Yield, ?Await]?

BindingRestElement[Yield, Await] :
  `...` BindingIdentifier[?Yield, ?Await]
  `...` BindingPattern[?Yield, ?Await]


EmptyStatement :
  `;`
    => empty_statement()

ExpressionStatement[Yield, Await] :
  [lookahead <! {`{`, `function`, `async`, `class`, `let`}] Expression[+In, ?Yield, ?Await] `;`
    => expression_statement($0)


IfStatement[Yield, Await, Return] :
  `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return] `else` Statement[?Yield, ?Await, ?Return]
    => if_statement($2, $4, Some($6))
  `if` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => if_statement($2, $4, None)


IterationStatement[Yield, Await, Return] :
  `do` Statement[?Yield, ?Await, ?Return] `while` `(` Expression[+In, ?Yield, ?Await] `)` `;`
    => do_while_statement($1, $4)
  `while` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => while_statement($2, $4)
  `for` `(` [lookahead <! {`let`}] Expression[~In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
    => for_statement(for_expression($2), $4, $6, $8)
  `for` `(` `var` VariableDeclarationList[~In, ?Yield, ?Await] `;` Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
    => for_statement(Some(for_var_declaration($3)), $5, $7, $9)
  `for` `(` ForLexicalDeclaration[~In, ?Yield, ?Await] Expression[+In, ?Yield, ?Await]? `;` Expression[+In, ?Yield, ?Await]? `)` Statement[?Yield, ?Await, ?Return]
    => for_statement(Some(unbox_for_lexical_declaration($2)), $3, $5, $7)
  `for` `(` [lookahead <! {`let`}] LeftHandSideExpression[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_in_statement(for_assignment_target($2), $4, $6)
  `for` `(` `var` ForBinding[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_in_statement(for_in_or_of_var_declaration($3), $5, $7)
  `for` `(` ForDeclaration[?Yield, ?Await] `in` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_in_statement(unbox_for_declaration($2), $4, $6)
  `for` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_of_statement(for_assignment_target($2), $4, $6)
  `for` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_of_statement(for_in_or_of_var_declaration($3), $5, $7)
  `for` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_of_statement(unbox_for_declaration($2), $4, $6)
  [+Await] `for` `await` `(` [lookahead != `let` ] LeftHandSideExpression[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_await_of_statement(for_assignment_target($3), $5, $7)
  [+Await] `for` `await` `(` `var` ForBinding[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_await_of_statement(for_in_or_of_var_declaration($4), $6, $8)
  [+Await] `for` `await` `(` ForDeclaration[?Yield, ?Await] `of` AssignmentExpression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => for_await_of_statement(unbox_for_declaration($3), $5, $7)

ForDeclaration[Yield, Await] :
  LetOrConst ForBinding[?Yield, ?Await]
    => for_declaration($0, $1)

ForBinding[Yield, Await] :
  BindingIdentifier[?Yield, ?Await]
    => binding_identifier($0)
  BindingPattern[?Yield, ?Await]
    => binding_pattern($0)


ContinueStatement[Yield, Await] :
  `continue` `;`
    => continue_statement(None)
  `continue` LabelIdentifier[?Yield, ?Await] `;`
    => continue_statement(Some($1))


BreakStatement[Yield, Await] :
  `break` `;`
    => break_statement(None)
  `break` LabelIdentifier[?Yield, ?Await] `;`
    => break_statement(Some($1))


ReturnStatement[Yield, Await] :
  `return` `;`
    => return_statement(None)
  `return` Expression[+In, ?Yield, ?Await] `;`
    => return_statement(Some($1))


WithStatement[Yield, Await, Return] :
  `with` `(` Expression[+In, ?Yield, ?Await] `)` Statement[?Yield, ?Await, ?Return]
    => with_statement($2, $4)


SwitchStatement[Yield, Await, Return] :
  `switch` `(` Expression[+In, ?Yield, ?Await] `)` CaseBlock[?Yield, ?Await, ?Return]
    => switch_statement($2, $4)

CaseBlock[Yield, Await, Return] :
  `{` CaseClauses[?Yield, ?Await, ?Return]? `}`
    => case_block($1)
  `{` CaseClauses[?Yield, ?Await, ?Return]? DefaultClause[?Yield, ?Await, ?Return] CaseClauses[?Yield, ?Await, ?Return]? `}`
    => case_block_with_default($1, $2, $3)

CaseClauses[Yield, Await, Return] :
  CaseClause[?Yield, ?Await, ?Return]
    => case_clauses_single($0)
  CaseClauses[?Yield, ?Await, ?Return] CaseClause[?Yield, ?Await, ?Return]
    => case_clauses_append($0, $1)

CaseClause[Yield, Await, Return] :
  `case` Expression[+In, ?Yield, ?Await] `:` StatementList[?Yield, ?Await, ?Return]?
    => case_clause($1, $3)

DefaultClause[Yield, Await, Return] :
  `default` `:` StatementList[?Yield, ?Await, ?Return]?
    => default_clause($2)


LabelledStatement[Yield, Await, Return] :
  LabelIdentifier[?Yield, ?Await] `:` LabelledItem[?Yield, ?Await, ?Return]
    => labelled_statement($0, $2)

LabelledItem[Yield, Await, Return] :
  Statement[?Yield, ?Await, ?Return] => $0
  FunctionDeclaration[?Yield, ?Await, ~Default] => $0


ThrowStatement[Yield, Await] :
  `throw` Expression[+In, ?Yield, ?Await] `;`
    => throw_statement($1)

TryStatement[Yield, Await, Return] :
  `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return]
    => try_statement($1, Some($2), None)
  `try` Block[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
    =>  try_statement($1, None, Some($2))
  `try` Block[?Yield, ?Await, ?Return] Catch[?Yield, ?Await, ?Return] Finally[?Yield, ?Await, ?Return]
    => try_statement($1, Some($2), Some($3))

Catch[Yield, Await, Return] :
  `catch` `(` CatchParameter[?Yield, ?Await] `)` Block[?Yield, ?Await, ?Return]
    => catch($2, $4)

Finally[Yield, Await, Return] :
  `finally` Block[?Yield, ?Await, ?Return]
    => $1

CatchParameter[Yield, Await] :
  BindingIdentifier[?Yield, ?Await]
    => binding_identifier($0)
  BindingPattern[?Yield, ?Await]
    => binding_pattern($0)


DebuggerStatement :
  `debugger` `;`
    => debugger_statement()


FunctionDeclaration[Yield, Await, Default] :
  `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
    => function_decl(function(Some($1), $3, $6))
  [+Default] `function` `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
    => function_decl(function(None, $2, $5))

FunctionExpression :
  `function` BindingIdentifier[~Yield, ~Await]? `(` FormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
    => function_expr(function($1, $3, $6))

UniqueFormalParameters[Yield, Await] :
  FormalParameters[?Yield, ?Await] => unique_formal_parameters($0)

FormalParameters[Yield, Await] :
  [empty]
    => empty_formal_parameters()
  FunctionRestParameter[?Yield, ?Await]
    => with_rest_parameter(empty_formal_parameters(), $0)
  FormalParameterList[?Yield, ?Await]
    => $0
  FormalParameterList[?Yield, ?Await] `,`
    => $0
  FormalParameterList[?Yield, ?Await] `,` FunctionRestParameter[?Yield, ?Await]
    => with_rest_parameter($0, $2)

FormalParameterList[Yield, Await] :
  FormalParameter[?Yield, ?Await]
    => singleton_formal_parameter_list($0)
  FormalParameterList[?Yield, ?Await] `,` FormalParameter[?Yield, ?Await]
    => append_formal_parameter($0, $2)

FunctionRestParameter[Yield, Await] :
  BindingRestElement[?Yield, ?Await]

FormalParameter[Yield, Await] :
  BindingElement[?Yield, ?Await]

FunctionBody[Yield, Await] :
  FunctionStatementList[?Yield, ?Await]
    => function_body($0)

FunctionStatementList[Yield, Await] :
  StatementList[?Yield, ?Await, +Return]?
    => function_statement_list($0)


ArrowFunction[In, Yield, Await] :
  ArrowParameters[?Yield, ?Await] `=>` ConciseBody[?In]

ArrowParameters[Yield, Await] :
  BindingIdentifier[?Yield, ?Await]
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover

ConciseBody[In] :
  [lookahead != `{` ] AssignmentExpression[?In, ~Yield, ~Await]
  `{` FunctionBody[~Yield, ~Await] `}`


ArrowFormalParameters[Yield, Await] :
  `(` UniqueFormalParameters[?Yield, ?Await] `)`


MethodDefinition[Yield, Await] :
  PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, ~Await] `)` `{` FunctionBody[~Yield, ~Await] `}`
  GeneratorMethod[?Yield, ?Await]
  AsyncMethod[?Yield, ?Await]
  AsyncGeneratorMethod[?Yield, ?Await]
  `get` PropertyName[?Yield, ?Await] `(` `)` `{` FunctionBody[~Yield, ~Await] `}`
  `set` PropertyName[?Yield, ?Await] `(` PropertySetParameterList `)` `{` FunctionBody[~Yield, ~Await] `}`

PropertySetParameterList :
  FormalParameter[~Yield, ~Await]


GeneratorMethod[Yield, Await] :
  `*` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`

GeneratorDeclaration[Yield, Await, Default] :
  `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
    => function_decl(generator(Some($2), $4, $7))
  [+Default] `function` `*` `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
    => function_decl(generator(None, $3, $6))

GeneratorExpression :
  `function` `*` BindingIdentifier[+Yield, ~Await]? `(` FormalParameters[+Yield, ~Await] `)` `{` GeneratorBody `}`
    => function_expr(generator($2, $4, $7))

GeneratorBody :
  FunctionBody[+Yield, ~Await]

YieldExpression[In, Await] :
  `yield`
    => yield_expr(None)
  `yield` AssignmentExpression[?In, +Yield, ?Await]
    => yield_expr(Some($1))
  `yield` `*` AssignmentExpression[?In, +Yield, ?Await]
    => yield_star_expr($2)


AsyncGeneratorMethod[Yield, Await] :
  `async` `*` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`

AsyncGeneratorDeclaration[Yield, Await, Default] :
  `async` `function` `*` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
    => function_decl(async_generator(Some($3), $5, $8))
  [+Default] `async` `function` `*` `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
    => function_decl(async_generator(None, $4, $7))

AsyncGeneratorExpression :
  `async` `function` `*` BindingIdentifier[+Yield, +Await]? `(` FormalParameters[+Yield, +Await] `)` `{` AsyncGeneratorBody `}`
    => function_expr(async_function($3, $5, $8))

AsyncGeneratorBody :
  FunctionBody[+Yield, +Await]


ClassDeclaration[Yield, Await, Default] :
  `class` BindingIdentifier[?Yield, ?Await] ClassTail[?Yield, ?Await]
  [+Default] `class` ClassTail[?Yield, ?Await]

ClassExpression[Yield, Await] :
  `class` BindingIdentifier[?Yield, ?Await]? ClassTail[?Yield, ?Await]

ClassTail[Yield, Await] :
  ClassHeritage[?Yield, ?Await]? `{` ClassBody[?Yield, ?Await]? `}`

ClassHeritage[Yield, Await] :
  `extends` LeftHandSideExpression[?Yield, ?Await]

ClassBody[Yield, Await] :
  ClassElementList[?Yield, ?Await]

ClassElementList[Yield, Await] :
  ClassElement[?Yield, ?Await]
  ClassElementList[?Yield, ?Await] ClassElement[?Yield, ?Await]

ClassElement[Yield, Await] :
  MethodDefinition[?Yield, ?Await]
  `static` MethodDefinition[?Yield, ?Await]
  `;`


AsyncFunctionDeclaration[Yield, Await, Default] :
  `async` `function` BindingIdentifier[?Yield, ?Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
    => function_decl(async_function(Some($2), $4, $7))
  [+Default] `async` `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
    => function_decl(async_function(None, $3, $6))

AsyncFunctionExpression :
  `async` `function` `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
    => function_expr(async_function(None, $3, $6))
  `async` `function` BindingIdentifier[~Yield, +Await] `(` FormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`
    => function_expr(async_function(Some($2), $4, $7))

AsyncMethod[Yield, Await] :
  `async` PropertyName[?Yield, ?Await] `(` UniqueFormalParameters[~Yield, +Await] `)` `{` AsyncFunctionBody `}`

AsyncFunctionBody :
  FunctionBody[~Yield, +Await]

AwaitExpression[Yield] :
  `await` UnaryExpression[?Yield, +Await]
    => await_expr($1)


AsyncArrowFunction[In, Yield, Await] :
  `async` AsyncArrowBindingIdentifier[?Yield] `=>` AsyncConciseBody[?In]
  CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await] `=>` AsyncConciseBody[?In] #callcover

AsyncConciseBody[In] :
  [lookahead != `{`] AssignmentExpression[?In, ~Yield, +Await]
  `{` AsyncFunctionBody `}`

AsyncArrowBindingIdentifier[Yield] :
  BindingIdentifier[?Yield, +Await]

CoverCallExpressionAndAsyncArrowHead[Yield, Await] :
  MemberExpression[?Yield, ?Await] Arguments[?Yield, ?Await]
    => call_expr($0, $1)


AsyncArrowHead :
  `async` ArrowFormalParameters[~Yield, +Await]


Script :
  ScriptBody?
    => script($0)

ScriptBody :
  StatementList[~Yield, ~Await, ~Return]
    => script_body($0)

Module :
  ModuleBody?

ModuleBody :
  ModuleItemList

ModuleItemList :
  ModuleItem
  ModuleItemList ModuleItem

ModuleItem :
  ImportDeclaration
  ExportDeclaration
  StatementListItem[~Yield, ~Await, ~Return]


ImportDeclaration :
  `import` ImportClause FromClause `;`
  `import` ModuleSpecifier `;`

ImportClause :
  ImportedDefaultBinding
  NameSpaceImport
  NamedImports
  ImportedDefaultBinding `,` NameSpaceImport
  ImportedDefaultBinding `,` NamedImports

ImportedDefaultBinding :
  ImportedBinding

NameSpaceImport :
  `*` `as` ImportedBinding

NamedImports :
  `{` `}`
  `{` ImportsList `}`
  `{` ImportsList `,` `}`

FromClause :
  `from` ModuleSpecifier

ImportsList :
  ImportSpecifier
  ImportsList `,` ImportSpecifier

ImportSpecifier :
  ImportedBinding
  IdentifierName `as` ImportedBinding

ModuleSpecifier :
  StringLiteral

ImportedBinding :
  BindingIdentifier[~Yield, ~Await]


ExportDeclaration :
  `export` `*` FromClause `;`
  `export` ExportClause FromClause `;`
  `export` ExportClause `;`
  `export` VariableStatement[~Yield, ~Await]
  `export` Declaration[~Yield, ~Await]
  `export` `default` HoistableDeclaration[~Yield, ~Await, +Default]
  `export` `default` ClassDeclaration[~Yield, ~Await, +Default]
  `export` `default` [lookahead <! {`function`, `async`, `class`}] AssignmentExpression[+In, ~Yield, ~Await] `;`

ExportClause :
  `{` `}`
  `{` ExportsList `}`
  `{` ExportsList `,` `}`

ExportsList :
  ExportSpecifier
  ExportsList `,` ExportSpecifier

ExportSpecifier :
  IdentifierName
  IdentifierName `as` IdentifierName

uri :::
  uriCharacters?

uriCharacters :::
  uriCharacter uriCharacters?

uriCharacter :::
  uriReserved
  uriUnescaped
  uriEscaped

uriReserved ::: one of
  `;` `/` `?` `:` `@` `&` `=` `+` `$` `,`

uriUnescaped :::
  uriAlpha
  DecimalDigit
  uriMark

uriEscaped :::
  `%` HexDigit HexDigit

uriAlpha ::: one of
  `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
  `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

uriMark ::: one of
  `-` `_` `.` `!` `~` `*` `'` `(` `)`


Pattern[U, N] ::
  Disjunction[?U, ?N]

Disjunction[U, N] ::
  Alternative[?U, ?N]
  Alternative[?U, ?N] `|` Disjunction[?U, ?N]

Alternative[U, N] ::
  [empty]
  Alternative[?U, ?N] Term[?U, ?N]

Term[U, N] ::
  Assertion[?U, ?N]
  Atom[?U, ?N]
  Atom[?U, ?N] Quantifier

Assertion[U, N] ::
  `^`
  `$`
  `\` `b`
  `\` `B`
  `(` `?` `=` Disjunction[?U, ?N] `)`
  `(` `?` `!` Disjunction[?U, ?N] `)`
  `(` `?` `<=` Disjunction[?U, ?N] `)`
  `(` `?` `<!` Disjunction[?U, ?N] `)`

Quantifier ::
  QuantifierPrefix
  QuantifierPrefix `?`

QuantifierPrefix ::
  `*`
  `+`
  `?`
  `{` DecimalDigits `}`
  `{` DecimalDigits `,` `}`
  `{` DecimalDigits `,` DecimalDigits `}`

Atom[U, N] ::
  PatternCharacter
  `.`
  `\` AtomEscape[?U, ?N]
  CharacterClass[?U]
  `(` GroupSpecifier[?U] Disjunction[?U, ?N] `)`
  `(` `?` `:` Disjunction[?U, ?N] `)`

SyntaxCharacter :: one of
  `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `]` `{` `}` `|`

PatternCharacter ::
  SourceCharacter but not SyntaxCharacter

AtomEscape[U, N] ::
  DecimalEscape
  CharacterClassEscape[?U]
  CharacterEscape[?U]
  [+N] `k` GroupName[?U]

CharacterEscape[U] ::
  ControlEscape
  `c` ControlLetter
  `0` [lookahead <! DecimalDigit]
  HexEscapeSequence
  RegExpUnicodeEscapeSequence[?U]
  IdentityEscape[?U]

ControlEscape :: one of
  `f` `n` `r` `t` `v`

ControlLetter :: one of
  `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`
  `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`

GroupSpecifier[U] ::
  [empty]
  `?` GroupName[?U]

GroupName[U] ::
  `<` RegExpIdentifierName[?U] `>`

RegExpIdentifierName[U] ::
  RegExpIdentifierStart[?U]
  RegExpIdentifierName[?U] RegExpIdentifierPart[?U]

RegExpIdentifierStart[U] ::
  UnicodeIDStart
  `$`
  `_`
  `\` RegExpUnicodeEscapeSequence[?U]

RegExpIdentifierPart[U] ::
  UnicodeIDContinue
  `$`
  `\` RegExpUnicodeEscapeSequence[?U]
  <ZWNJ>
  <ZWJ>

RegExpUnicodeEscapeSequence[U] ::
  [+U] `u` LeadSurrogate `\u` TrailSurrogate
  [+U] `u` LeadSurrogate
  [+U] `u` TrailSurrogate
  [+U] `u` NonSurrogate
  [~U] `u` Hex4Digits
  [+U] `u{` CodePoint `}`


LeadSurrogate ::
  Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xD800 to 0xDBFF]

TrailSurrogate ::
  Hex4Digits [> but only if the SV of |Hex4Digits| is in the inclusive range 0xDC00 to 0xDFFF]

NonSurrogate ::
  Hex4Digits [> but only if the SV of |Hex4Digits| is not in the inclusive range 0xD800 to 0xDFFF]

IdentityEscape[U] ::
  [+U] SyntaxCharacter
  [+U] `/`
  [~U] SourceCharacter but not UnicodeIDContinue

DecimalEscape ::
  NonZeroDigit DecimalDigits? [lookahead <! DecimalDigit]

CharacterClassEscape[U] ::
  `d`
  `D`
  `s`
  `S`
  `w`
  `W`
  [+U] `p{` UnicodePropertyValueExpression `}`
  [+U] `P{` UnicodePropertyValueExpression `}`

UnicodePropertyValueExpression ::
  UnicodePropertyName `=` UnicodePropertyValue
  LoneUnicodePropertyNameOrValue

UnicodePropertyName ::
  UnicodePropertyNameCharacters

UnicodePropertyNameCharacters ::
  UnicodePropertyNameCharacter UnicodePropertyNameCharacters?

UnicodePropertyValue ::
  UnicodePropertyValueCharacters

LoneUnicodePropertyNameOrValue ::
  UnicodePropertyValueCharacters

UnicodePropertyValueCharacters ::
  UnicodePropertyValueCharacter UnicodePropertyValueCharacters?

UnicodePropertyValueCharacter ::
  UnicodePropertyNameCharacter
  `0`
  `1`
  `2`
  `3`
  `4`
  `5`
  `6`
  `7`
  `8`
  `9`

UnicodePropertyNameCharacter ::
  ControlLetter
  `_`

CharacterClass[U] ::
  `[` [lookahead <! {`^`}] ClassRanges[?U] `]`
  `[` `^` ClassRanges[?U] `]`

ClassRanges[U] ::
  [empty]
  NonemptyClassRanges[?U]

NonemptyClassRanges[U] ::
  ClassAtom[?U]
  ClassAtom[?U] NonemptyClassRangesNoDash[?U]
  ClassAtom[?U] `-` ClassAtom[?U] ClassRanges[?U]

NonemptyClassRangesNoDash[U] ::
  ClassAtom[?U]
  ClassAtomNoDash[?U] NonemptyClassRangesNoDash[?U]
  ClassAtomNoDash[?U] `-` ClassAtom[?U] ClassRanges[?U]

ClassAtom[U] ::
  `-`
  ClassAtomNoDash[?U]

ClassAtomNoDash[U] ::
  SourceCharacter but not one of `\` or `]` or `-`
  `\` ClassEscape[?U]

ClassEscape[U] ::
  `b`
  [+U] `-`
  CharacterClassEscape[?U]
  CharacterEscape[?U]


DoubleStringCharacter ::
  SourceCharacter but not one of `"` or `\` or U+0000 through U+001F
  `\` EscapeSequence


NumericLiteral ::
  DecimalLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexIntegerLiteral
  LegacyOctalIntegerLiteral

LegacyOctalIntegerLiteral ::
  `0` OctalDigit
  LegacyOctalIntegerLiteral OctalDigit

DecimalIntegerLiteral ::
  `0`
  NonZeroDigit DecimalDigits?
  NonOctalDecimalIntegerLiteral

NonOctalDecimalIntegerLiteral ::
  `0` NonOctalDigit
  LegacyOctalLikeDecimalIntegerLiteral NonOctalDigit
  NonOctalDecimalIntegerLiteral DecimalDigit

LegacyOctalLikeDecimalIntegerLiteral ::
  `0` OctalDigit
  LegacyOctalLikeDecimalIntegerLiteral OctalDigit

NonOctalDigit :: one of
  `8` `9`


EscapeSequence ::
  CharacterEscapeSequence
  LegacyOctalEscapeSequence
  HexEscapeSequence
  UnicodeEscapeSequence

LegacyOctalEscapeSequence ::
  OctalDigit [lookahead <! OctalDigit]
  ZeroToThree OctalDigit [lookahead <! OctalDigit]
  FourToSeven OctalDigit
  ZeroToThree OctalDigit OctalDigit

ZeroToThree :: one of
  `0` `1` `2` `3`

FourToSeven :: one of
  `4` `5` `6` `7`


Comment ::
  MultiLineComment
  SingleLineComment
  SingleLineHTMLOpenComment
  SingleLineHTMLCloseComment
  SingleLineDelimitedComment

MultiLineComment ::
  `/*` FirstCommentLine? LineTerminator MultiLineCommentChars? `*/` HTMLCloseComment?

FirstCommentLine ::
  SingleLineDelimitedCommentChars

SingleLineHTMLOpenComment ::
  `<!--` SingleLineCommentChars?

SingleLineHTMLCloseComment ::
  LineTerminatorSequence HTMLCloseComment

SingleLineDelimitedComment ::
  `/*` SingleLineDelimitedCommentChars? `*/`

HTMLCloseComment ::
  WhiteSpaceSequence? SingleLineDelimitedCommentSequence? `-->` SingleLineCommentChars?

SingleLineDelimitedCommentChars ::
  SingleLineNotAsteriskChar SingleLineDelimitedCommentChars?
  `*` SingleLinePostAsteriskCommentChars?

SingleLineNotAsteriskChar ::
  SourceCharacter but not one of `*` or LineTerminator

SingleLinePostAsteriskCommentChars ::
  SingleLineNotForwardSlashOrAsteriskChar SingleLineDelimitedCommentChars?
  `*` SingleLinePostAsteriskCommentChars?

SingleLineNotForwardSlashOrAsteriskChar ::
  SourceCharacter but not one of `/` or `*` or LineTerminator

WhiteSpaceSequence ::
  WhiteSpace WhiteSpaceSequence?

SingleLineDelimitedCommentSequence ::
  SingleLineDelimitedComment WhiteSpaceSequence? SingleLineDelimitedCommentSequence?


Term[U, N] ::
  [+U] Assertion[+U, ?N]
  [+U] Atom[+U, ?N]
  [+U] Atom[+U, ?N] Quantifier
  [~U] QuantifiableAssertion[?N] Quantifier
  [~U] Assertion[~U, ?N]
  [~U] ExtendedAtom[?N] Quantifier
  [~U] ExtendedAtom[?N]

Assertion[U, N] ::
  `^`
  `$`
  `\` `b`
  `\` `B`
  [+U] `(` `?` `=` Disjunction[+U, ?N] `)`
  [+U] `(` `?` `!` Disjunction[+U, ?N] `)`
  [~U] QuantifiableAssertion[?N]
  `(` `?` `<=` Disjunction[?U, ?N] `)`
  `(` `?` `<!` Disjunction[?U, ?N] `)`

QuantifiableAssertion[N] ::
  `(` `?` `=` Disjunction[~U, ?N] `)`
  `(` `?` `!` Disjunction[~U, ?N] `)`

ExtendedAtom[N] ::
  `.`
  `\` AtomEscape[~U, ?N]
  `\` [lookahead == `c`]
  CharacterClass[~U]
  `(` Disjunction[~U, ?N] `)`
  `(` `?` `:` Disjunction[~U, ?N] `)`
  InvalidBracedQuantifier
  ExtendedPatternCharacter

InvalidBracedQuantifier ::
  `{` DecimalDigits `}`
  `{` DecimalDigits `,` `}`
  `{` DecimalDigits `,` DecimalDigits `}`

ExtendedPatternCharacter ::
  SourceCharacter but not one of `^` `$` `\` `.` `*` `+` `?` `(` `)` `[` `|`

AtomEscape[U, N] ::
  [+U] DecimalEscape
  [~U] DecimalEscape [> but only if the CapturingGroupNumber of |DecimalEscape| is <= _NcapturingParens_]
  CharacterClassEscape[?U]
  CharacterEscape[~U, ?N]
  [+N] `k` GroupName[?U]

CharacterEscape[U, N] ::
  ControlEscape
  `c` ControlLetter
  `0` [lookahead <! DecimalDigit]
  HexEscapeSequence
  RegExpUnicodeEscapeSequence[?U]
  [~U] LegacyOctalEscapeSequence
  IdentityEscape[?U, ?N]

IdentityEscape[U, N] ::
  [+U] SyntaxCharacter
  [+U] `/`
  [~U] SourceCharacterIdentityEscape[?N]

SourceCharacterIdentityEscape[N] ::
  [~N] SourceCharacter but not `c`
  [+N] SourceCharacter but not one of `c` or `k`

ClassAtomNoDash[U, N] ::
  SourceCharacter but not one of `\` or `]` or `-`
  `\` ClassEscape[?U, ?N]
  `\` [lookahead == `c`]

ClassEscape[U, N] ::
  `b`
  [+U] `-`
  [~U] `c` ClassControlLetter
  CharacterClassEscape[?U]
  CharacterEscape[?U, ?N]

ClassControlLetter ::
  DecimalDigit
  `_`

