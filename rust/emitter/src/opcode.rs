use std::convert::TryFrom;

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
#[repr(u8)]
pub enum Opcode {
    Undefined,
    Null,
    False,
    True,
    Int32,
    Zero,
    One,
    Int8,
    Uint16,
    Uint24,
    Double,
    BigInt,
    String,
    Symbol,
    Void,
    Typeof,
    TypeofExpr,
    Pos,
    Neg,
    BitNot,
    Not,
    BitOr,
    BitXor,
    BitAnd,
    Eq,
    Ne,
    StrictEq,
    StrictNe,
    Lt,
    Gt,
    Le,
    Ge,
    Instanceof,
    In,
    Lsh,
    Rsh,
    Ursh,
    Add,
    Sub,
    Inc,
    Dec,
    Mul,
    Div,
    Mod,
    Pow,
    ToId,
    ToNumeric,
    ToString,
    GlobalThis,
    NewTarget,
    DynamicImport,
    ImportMeta,
    NewInit,
    NewObject,
    NewObjectWithGroup,
    Object,
    ObjWithProto,
    InitProp,
    InitHiddenProp,
    InitLockedProp,
    InitElem,
    InitHiddenElem,
    InitPropGetter,
    InitHiddenPropGetter,
    InitElemGetter,
    InitHiddenElemGetter,
    InitPropSetter,
    InitHiddenPropSetter,
    InitElemSetter,
    InitHiddenElemSetter,
    GetProp,
    CallProp,
    GetElem,
    CallElem,
    Length,
    SetProp,
    StrictSetProp,
    SetElem,
    StrictSetElem,
    DelProp,
    StrictDelProp,
    DelElem,
    StrictDelElem,
    HasOwn,
    SuperBase,
    GetPropSuper,
    GetElemSuper,
    SetPropSuper,
    StrictSetPropSuper,
    SetElemSuper,
    StrictSetElemSuper,
    Iter,
    MoreIter,
    IsNoIter,
    IterNext,
    EndIter,
    CheckIsObj,
    CheckIsCallable,
    CheckObjCoercible,
    ToAsyncIter,
    MutateProto,
    NewArray,
    InitElemArray,
    InitElemInc,
    Hole,
    NewArrayCopyOnWrite,
    RegExp,
    Lambda,
    LambdaArrow,
    SetFunName,
    InitHomeObject,
    CheckClassHeritage,
    FunWithProto,
    ClassConstructor,
    DerivedConstructor,
    BuiltinProto,
    Call,
    CallIter,
    FunApply,
    FunCall,
    CallIgnoresRv,
    SpreadCall,
    OptimizeSpreadCall,
    Eval,
    SpreadEval,
    StrictEval,
    StrictSpreadEval,
    ImplicitThis,
    GImplicitThis,
    CallSiteObj,
    IsConstructing,
    New,
    SpreadNew,
    SuperFun,
    SuperCall,
    SpreadSuperCall,
    CheckThisReinit,
    Generator,
    InitialYield,
    AfterYield,
    FinalYieldRval,
    Yield,
    IsGenClosing,
    AsyncAwait,
    AsyncResolve,
    Await,
    TrySkipAwait,
    Resume,
    JumpTarget,
    LoopHead,
    Goto,
    IfEq,
    IfNe,
    And,
    Or,
    Coalesce,
    Case,
    Default,
    TableSwitch,
    Return,
    GetRval,
    SetRval,
    RetRval,
    CheckReturn,
    Throw,
    ThrowMsg,
    ThrowSetAliasedConst,
    ThrowSetCallee,
    ThrowSetConst,
    Try,
    TryDestructuring,
    Exception,
    ResumeIndex,
    Gosub,
    Finally,
    Retsub,
    Uninitialized,
    InitLexical,
    InitGLexical,
    InitAliasedLexical,
    CheckLexical,
    CheckAliasedLexical,
    CheckThis,
    BindGname,
    BindName,
    GetName,
    GetGname,
    GetArg,
    GetLocal,
    GetAliasedVar,
    GetImport,
    GetBoundName,
    GetIntrinsic,
    Callee,
    EnvCallee,
    SetName,
    StrictSetName,
    SetGname,
    StrictSetGname,
    SetArg,
    SetLocal,
    SetAliasedVar,
    SetIntrinsic,
    PushLexicalEnv,
    PopLexicalEnv,
    DebugLeaveLexicalEnv,
    RecreateLexicalEnv,
    FreshenLexicalEnv,
    PushVarEnv,
    PopVarEnv,
    EnterWith,
    LeaveWith,
    BindVar,
    DefVar,
    DefFun,
    DefLet,
    DefConst,
    DelName,
    Arguments,
    Rest,
    FunctionThis,
    Pop,
    PopN,
    Dup,
    Dup2,
    DupAt,
    Swap,
    Pick,
    Unpick,
    Nop,
    Lineno,
    NopDestructuring,
    ForceInterpreter,
    DebugCheckSelfHosted,
    InstrumentationActive,
    InstrumentationCallback,
    InstrumentationScriptId,
    Debugger,
}

const LIMIT: usize = 238;

impl Opcode {
    /// Return the numeric bytecode value for this opcode, as understood by the
    /// SpiderMonkey interpreter and the rest of the VM.
    pub fn to_byte(&self) -> u8 {
        *self as u8
    }

    /// True if this opcode takes no operands (is a one-byte opcode) and
    /// implements a unary operator that operates on one stack value.
    ///
    /// The operators `typeof` and `delete` have different bytecode patterns
    /// and thus are not considered "simple"; `new` is considered a special
    /// kind of function call, not a unary operator.
    pub fn is_simple_unary_operator(self) -> bool {
        self == Opcode::Pos
            || self == Opcode::Neg
            || self == Opcode::Not
            || self == Opcode::BitNot
            || self == Opcode::Void
    }

    /// True if this opcode takes no operands (is a one-byte opcode) and
    /// implements a binary operator that operates on two stack values.
    ///
    /// The operators `||`, `&&`, and `,` have different bytecode patterns
    /// and thus are not considered "simple".
    pub fn is_simple_binary_operator(self) -> bool {
        self == Opcode::BitOr
            || self == Opcode::BitXor
            || self == Opcode::BitAnd
            || self == Opcode::Eq
            || self == Opcode::Ne
            || self == Opcode::StrictEq
            || self == Opcode::StrictNe
            || self == Opcode::Lt
            || self == Opcode::Gt
            || self == Opcode::Le
            || self == Opcode::Ge
            || self == Opcode::Instanceof
            || self == Opcode::In
            || self == Opcode::Lsh
            || self == Opcode::Rsh
            || self == Opcode::Ursh
            || self == Opcode::Add
            || self == Opcode::Sub
            || self == Opcode::Mul
            || self == Opcode::Div
            || self == Opcode::Mod
            || self == Opcode::Pow
    }
}

impl TryFrom<u8> for Opcode {
    type Error = ();

    fn try_from(value: u8) -> Result<Opcode, ()> {
        if (value as usize) < LIMIT {
            Ok(TABLE[value as usize])
        } else {
            Err(())
        }
    }
}

pub static TABLE: [Opcode; LIMIT] = [
    Opcode::Undefined,
    Opcode::Null,
    Opcode::False,
    Opcode::True,
    Opcode::Int32,
    Opcode::Zero,
    Opcode::One,
    Opcode::Int8,
    Opcode::Uint16,
    Opcode::Uint24,
    Opcode::Double,
    Opcode::BigInt,
    Opcode::String,
    Opcode::Symbol,
    Opcode::Void,
    Opcode::Typeof,
    Opcode::TypeofExpr,
    Opcode::Pos,
    Opcode::Neg,
    Opcode::BitNot,
    Opcode::Not,
    Opcode::BitOr,
    Opcode::BitXor,
    Opcode::BitAnd,
    Opcode::Eq,
    Opcode::Ne,
    Opcode::StrictEq,
    Opcode::StrictNe,
    Opcode::Lt,
    Opcode::Gt,
    Opcode::Le,
    Opcode::Ge,
    Opcode::Instanceof,
    Opcode::In,
    Opcode::Lsh,
    Opcode::Rsh,
    Opcode::Ursh,
    Opcode::Add,
    Opcode::Sub,
    Opcode::Inc,
    Opcode::Dec,
    Opcode::Mul,
    Opcode::Div,
    Opcode::Mod,
    Opcode::Pow,
    Opcode::ToId,
    Opcode::ToNumeric,
    Opcode::ToString,
    Opcode::GlobalThis,
    Opcode::NewTarget,
    Opcode::DynamicImport,
    Opcode::ImportMeta,
    Opcode::NewInit,
    Opcode::NewObject,
    Opcode::NewObjectWithGroup,
    Opcode::Object,
    Opcode::ObjWithProto,
    Opcode::InitProp,
    Opcode::InitHiddenProp,
    Opcode::InitLockedProp,
    Opcode::InitElem,
    Opcode::InitHiddenElem,
    Opcode::InitPropGetter,
    Opcode::InitHiddenPropGetter,
    Opcode::InitElemGetter,
    Opcode::InitHiddenElemGetter,
    Opcode::InitPropSetter,
    Opcode::InitHiddenPropSetter,
    Opcode::InitElemSetter,
    Opcode::InitHiddenElemSetter,
    Opcode::GetProp,
    Opcode::CallProp,
    Opcode::GetElem,
    Opcode::CallElem,
    Opcode::Length,
    Opcode::SetProp,
    Opcode::StrictSetProp,
    Opcode::SetElem,
    Opcode::StrictSetElem,
    Opcode::DelProp,
    Opcode::StrictDelProp,
    Opcode::DelElem,
    Opcode::StrictDelElem,
    Opcode::HasOwn,
    Opcode::SuperBase,
    Opcode::GetPropSuper,
    Opcode::GetElemSuper,
    Opcode::SetPropSuper,
    Opcode::StrictSetPropSuper,
    Opcode::SetElemSuper,
    Opcode::StrictSetElemSuper,
    Opcode::Iter,
    Opcode::MoreIter,
    Opcode::IsNoIter,
    Opcode::IterNext,
    Opcode::EndIter,
    Opcode::CheckIsObj,
    Opcode::CheckIsCallable,
    Opcode::CheckObjCoercible,
    Opcode::ToAsyncIter,
    Opcode::MutateProto,
    Opcode::NewArray,
    Opcode::InitElemArray,
    Opcode::InitElemInc,
    Opcode::Hole,
    Opcode::NewArrayCopyOnWrite,
    Opcode::RegExp,
    Opcode::Lambda,
    Opcode::LambdaArrow,
    Opcode::SetFunName,
    Opcode::InitHomeObject,
    Opcode::CheckClassHeritage,
    Opcode::FunWithProto,
    Opcode::ClassConstructor,
    Opcode::DerivedConstructor,
    Opcode::BuiltinProto,
    Opcode::Call,
    Opcode::CallIter,
    Opcode::FunApply,
    Opcode::FunCall,
    Opcode::CallIgnoresRv,
    Opcode::SpreadCall,
    Opcode::OptimizeSpreadCall,
    Opcode::Eval,
    Opcode::SpreadEval,
    Opcode::StrictEval,
    Opcode::StrictSpreadEval,
    Opcode::ImplicitThis,
    Opcode::GImplicitThis,
    Opcode::CallSiteObj,
    Opcode::IsConstructing,
    Opcode::New,
    Opcode::SpreadNew,
    Opcode::SuperFun,
    Opcode::SuperCall,
    Opcode::SpreadSuperCall,
    Opcode::CheckThisReinit,
    Opcode::Generator,
    Opcode::InitialYield,
    Opcode::AfterYield,
    Opcode::FinalYieldRval,
    Opcode::Yield,
    Opcode::IsGenClosing,
    Opcode::AsyncAwait,
    Opcode::AsyncResolve,
    Opcode::Await,
    Opcode::TrySkipAwait,
    Opcode::Resume,
    Opcode::JumpTarget,
    Opcode::LoopHead,
    Opcode::Goto,
    Opcode::IfEq,
    Opcode::IfNe,
    Opcode::And,
    Opcode::Or,
    Opcode::Coalesce,
    Opcode::Case,
    Opcode::Default,
    Opcode::TableSwitch,
    Opcode::Return,
    Opcode::GetRval,
    Opcode::SetRval,
    Opcode::RetRval,
    Opcode::CheckReturn,
    Opcode::Throw,
    Opcode::ThrowMsg,
    Opcode::ThrowSetAliasedConst,
    Opcode::ThrowSetCallee,
    Opcode::ThrowSetConst,
    Opcode::Try,
    Opcode::TryDestructuring,
    Opcode::Exception,
    Opcode::ResumeIndex,
    Opcode::Gosub,
    Opcode::Finally,
    Opcode::Retsub,
    Opcode::Uninitialized,
    Opcode::InitLexical,
    Opcode::InitGLexical,
    Opcode::InitAliasedLexical,
    Opcode::CheckLexical,
    Opcode::CheckAliasedLexical,
    Opcode::CheckThis,
    Opcode::BindGname,
    Opcode::BindName,
    Opcode::GetName,
    Opcode::GetGname,
    Opcode::GetArg,
    Opcode::GetLocal,
    Opcode::GetAliasedVar,
    Opcode::GetImport,
    Opcode::GetBoundName,
    Opcode::GetIntrinsic,
    Opcode::Callee,
    Opcode::EnvCallee,
    Opcode::SetName,
    Opcode::StrictSetName,
    Opcode::SetGname,
    Opcode::StrictSetGname,
    Opcode::SetArg,
    Opcode::SetLocal,
    Opcode::SetAliasedVar,
    Opcode::SetIntrinsic,
    Opcode::PushLexicalEnv,
    Opcode::PopLexicalEnv,
    Opcode::DebugLeaveLexicalEnv,
    Opcode::RecreateLexicalEnv,
    Opcode::FreshenLexicalEnv,
    Opcode::PushVarEnv,
    Opcode::PopVarEnv,
    Opcode::EnterWith,
    Opcode::LeaveWith,
    Opcode::BindVar,
    Opcode::DefVar,
    Opcode::DefFun,
    Opcode::DefLet,
    Opcode::DefConst,
    Opcode::DelName,
    Opcode::Arguments,
    Opcode::Rest,
    Opcode::FunctionThis,
    Opcode::Pop,
    Opcode::PopN,
    Opcode::Dup,
    Opcode::Dup2,
    Opcode::DupAt,
    Opcode::Swap,
    Opcode::Pick,
    Opcode::Unpick,
    Opcode::Nop,
    Opcode::Lineno,
    Opcode::NopDestructuring,
    Opcode::ForceInterpreter,
    Opcode::DebugCheckSelfHosted,
    Opcode::InstrumentationActive,
    Opcode::InstrumentationCallback,
    Opcode::InstrumentationScriptId,
    Opcode::Debugger,
];

pub static LENGTH: [u8; LIMIT] = [
    1, 1, 1, 1, 5, 1, 1, 2, 3, 4, 9, 5, 5, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 1, 5, 5, 5, 1, 1, 5, 5,
    1, 1, 5, 5, 1, 1, 5, 5, 1, 1, 5, 5, 5, 1, 1, 5, 5, 1, 1, 1, 1, 5, 1, 5, 5, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 1, 1, 1, 5, 5, 1, 1, 5, 5, 5, 5, 2, 1, 1, 5, 13, 13, 2, 3, 3, 3, 3, 3, 1, 1, 3, 1, 3, 1,
    5, 5, 5, 1, 3, 1, 1, 3, 1, 1, 1, 4, 5, 1, 4, 1, 1, 2, 4, 1, 2, 5, 6, 5, 5, 5, 5, 5, 5, 5, 5,
    16, 1, 1, 1, 1, 1, 1, 3, 5, 1, 4, 1, 1, 1, 4, 5, 1, 1, 1, 4, 5, 5, 4, 5, 1, 5, 5, 5, 5, 3, 4,
    5, 5, 5, 5, 1, 2, 5, 5, 5, 5, 3, 4, 5, 5, 5, 1, 1, 1, 1, 5, 1, 5, 1, 1, 5, 1, 5, 5, 5, 1, 1, 1,
    1, 3, 1, 1, 4, 1, 2, 2, 1, 5, 1, 1, 1, 1, 1, 1, 1,
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn table_matches() {
        for (i, t) in TABLE.iter().enumerate() {
            assert_eq!(i, t.to_byte() as usize);
        }
    }
}
