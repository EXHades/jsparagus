// THIS FILE IS AUTOGENERATED -- HAHAHAHA

use super::parser_runtime::{self, Node, ParserTables, TokenStream};

const ERROR: i64 = -0x8000000000000000;

#[derive(Copy, Clone, Debug)]
pub enum TokenType {
    Nt = 0, // 'nt'
    Goal = 1, // 'goal'
    Identifier = 2, // 'IDENT'
    End = 3, // None
    OpenBrace = 4, // '{'
    CloseBrace = 5, // '}'
    String = 6, // 'STR'
    Semicolon = 7, // ';'
    QuestionMark = 8, // '?'
}

static ACTIONS: [i64; 261] = [
    // 0. <empty>
    1, 2, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 1. "nt"
    ERROR, ERROR, 5, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 2. "goal"
    6, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 3. grammar
    1, 2, ERROR, -9223372036854775807, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 4. nt_def
    -1, -1, ERROR, -1, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 5. "nt" "IDENT"
    ERROR, ERROR, ERROR, ERROR, 8, ERROR, ERROR, ERROR, ERROR,

    // 6. "goal" "nt"
    ERROR, ERROR, 9, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 7. grammar nt_def
    -2, -2, ERROR, -2, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 8. "nt" "IDENT" "{"
    ERROR, ERROR, 11, ERROR, ERROR, 10, 12, ERROR, ERROR,

    // 9. "goal" "nt" "IDENT"
    ERROR, ERROR, ERROR, ERROR, 18, ERROR, ERROR, ERROR, ERROR,

    // 10. "nt" "IDENT" "{" "}"
    -3, -3, ERROR, -3, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 11. "nt" "IDENT" "{" "IDENT"
    ERROR, ERROR, -14, ERROR, ERROR, ERROR, -14, -14, -14,

    // 12. "nt" "IDENT" "{" "STR"
    ERROR, ERROR, -15, ERROR, ERROR, ERROR, -15, -15, -15,

    // 13. "nt" "IDENT" "{" prods
    ERROR, ERROR, 11, ERROR, ERROR, 19, 12, ERROR, ERROR,

    // 14. "nt" "IDENT" "{" prod
    ERROR, ERROR, -7, ERROR, ERROR, -7, -7, ERROR, ERROR,

    // 15. "nt" "IDENT" "{" terms
    ERROR, ERROR, 22, ERROR, ERROR, ERROR, 23, 21, ERROR,

    // 16. "nt" "IDENT" "{" term
    ERROR, ERROR, -10, ERROR, ERROR, ERROR, -10, -10, ERROR,

    // 17. "nt" "IDENT" "{" symbol
    ERROR, ERROR, -12, ERROR, ERROR, ERROR, -12, -12, 25,

    // 18. "goal" "nt" "IDENT" "{"
    ERROR, ERROR, 11, ERROR, ERROR, 26, 12, ERROR, ERROR,

    // 19. "nt" "IDENT" "{" prods "}"
    -4, -4, ERROR, -4, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 20. "nt" "IDENT" "{" prods prod
    ERROR, ERROR, -8, ERROR, ERROR, -8, -8, ERROR, ERROR,

    // 21. "nt" "IDENT" "{" terms ";"
    ERROR, ERROR, -9, ERROR, ERROR, -9, -9, ERROR, ERROR,

    // 22. "nt" "IDENT" "{" terms "IDENT"
    ERROR, ERROR, -14, ERROR, ERROR, ERROR, -14, -14, -14,

    // 23. "nt" "IDENT" "{" terms "STR"
    ERROR, ERROR, -15, ERROR, ERROR, ERROR, -15, -15, -15,

    // 24. "nt" "IDENT" "{" terms term
    ERROR, ERROR, -11, ERROR, ERROR, ERROR, -11, -11, ERROR,

    // 25. "nt" "IDENT" "{" symbol "?"
    ERROR, ERROR, -13, ERROR, ERROR, ERROR, -13, -13, ERROR,

    // 26. "goal" "nt" "IDENT" "{" "}"
    -5, -5, ERROR, -5, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 27. "goal" "nt" "IDENT" "{" prods
    ERROR, ERROR, 11, ERROR, ERROR, 28, 12, ERROR, ERROR,

    // 28. "goal" "nt" "IDENT" "{" prods "}"
    -6, -6, ERROR, -6, ERROR, ERROR, ERROR, ERROR, ERROR,
];

static GOTO: [usize; 203] = [
    3, 4, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 7, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 13, 14, 15, 16, 17,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 20, 15, 16, 17,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 24, 17,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 27, 14, 15, 16, 17,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 20, 15, 16, 17,
    0, 0, 0, 0, 0, 0, 0,
];

fn reduce(prod: usize, stack: &mut Vec<Node>) -> usize {
    match prod {
        0 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("grammar", 0, vec![Some(x0)]));
            0
        }
        1 => {
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("grammar", 1, vec![Some(x0), Some(x1)]));
            0
        }
        2 => {
            let x3 = stack.pop().unwrap();
            let x2 = stack.pop().unwrap();
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("nt_def", 0, vec![Some(x0), Some(x1), Some(x2), None, Some(x3)]));
            1
        }
        3 => {
            let x4 = stack.pop().unwrap();
            let x3 = stack.pop().unwrap();
            let x2 = stack.pop().unwrap();
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("nt_def", 0, vec![Some(x0), Some(x1), Some(x2), Some(x3), Some(x4)]));
            1
        }
        4 => {
            let x4 = stack.pop().unwrap();
            let x3 = stack.pop().unwrap();
            let x2 = stack.pop().unwrap();
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("nt_def", 1, vec![Some(x0), Some(x1), Some(x2), Some(x3), None, Some(x4)]));
            1
        }
        5 => {
            let x5 = stack.pop().unwrap();
            let x4 = stack.pop().unwrap();
            let x3 = stack.pop().unwrap();
            let x2 = stack.pop().unwrap();
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("nt_def", 1, vec![Some(x0), Some(x1), Some(x2), Some(x3), Some(x4), Some(x5)]));
            1
        }
        6 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("prods", 0, vec![Some(x0)]));
            2
        }
        7 => {
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("prods", 1, vec![Some(x0), Some(x1)]));
            2
        }
        8 => {
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("prod", 0, vec![Some(x0), Some(x1)]));
            3
        }
        9 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("terms", 0, vec![Some(x0)]));
            4
        }
        10 => {
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("terms", 1, vec![Some(x0), Some(x1)]));
            4
        }
        11 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("term", 0, vec![Some(x0)]));
            5
        }
        12 => {
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("term", 1, vec![Some(x0), Some(x1)]));
            5
        }
        13 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("symbol", 0, vec![Some(x0)]));
            6
        }
        14 => {
            let x0 = stack.pop().unwrap();
            stack.push(Node::new("symbol", 1, vec![Some(x0)]));
            6
        }
        _ => panic!("no such production: {}", prod),
    }
}

static TABLES: ParserTables<'static> = ParserTables {
    state_count: 29,
    action_table: &ACTIONS,
    action_width: 9,
    goto_table: &GOTO,
    goto_width: 7,
};

pub fn parse_grammar<In: TokenStream<Token=crate::ast::Token>>(
    tokens: In,
) -> Result<Node, &'static str> {
    parser_runtime::parse(tokens, 0, &TABLES, reduce)
}

