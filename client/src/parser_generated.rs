// THIS FILE IS AUTOGENERATED -- HAHAHAHA

use super::parser_runtime::{self, ParserTables, TokenStream};

const ERROR: i64 = -0x8000000000000000;

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum TerminalId {
    Nt = 0, // 'nt'
    Goal = 1, // 'goal'
    Token = 2, // 'token'
    Var = 3, // 'var'
    Ident = 4, // 'IDENT'
    End = 5, // None
    LeftCurlyBracket = 6, // '{'
    EqualsSign = 7, // '='
    RightCurlyBracket = 8, // '}'
    Str = 9, // 'STR'
    Semicolon = 10, // ';'
    QuestionMark = 11, // '?'
    Arrow = 12, // '=>'
}

#[derive(Clone, Debug, PartialEq)]
pub enum Token {
    Nt, // 'nt'
    Goal, // 'goal'
    Token, // 'token'
    Var, // 'var'
    Ident(String), // 'IDENT'
    End, // None
    LeftCurlyBracket, // '{'
    EqualsSign, // '='
    RightCurlyBracket, // '}'
    Str(String), // 'STR'
    Semicolon, // ';'
    QuestionMark, // '?'
    Arrow, // '=>'
}

impl Token {
    pub fn get_id(&self) -> TerminalId {
        // This switch should be optimized away.
        match self {
            Token::Nt => TerminalId::Nt,
            Token::Goal => TerminalId::Goal,
            Token::Token => TerminalId::Token,
            Token::Var => TerminalId::Var,
            Token::Ident(_) => TerminalId::Ident,
            Token::End => TerminalId::End,
            Token::LeftCurlyBracket => TerminalId::LeftCurlyBracket,
            Token::EqualsSign => TerminalId::EqualsSign,
            Token::RightCurlyBracket => TerminalId::RightCurlyBracket,
            Token::Str(_) => TerminalId::Str,
            Token::Semicolon => TerminalId::Semicolon,
            Token::QuestionMark => TerminalId::QuestionMark,
            Token::Arrow => TerminalId::Arrow,
        }
    }
}

#[derive(Debug)]
pub enum Node<T> {
    Terminal(Token),
    Nonterminal(Box<T>),
}

static ACTIONS: [i64; 585] = [
    // 0. <empty>
    1, 2, 3, 4, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 1. "nt"
    ERROR, ERROR, ERROR, ERROR, 10, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 2. "goal"
    11, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 3. "token"
    ERROR, ERROR, ERROR, ERROR, 12, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 4. "var"
    ERROR, ERROR, 13, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 5. grammar
    ERROR, ERROR, ERROR, ERROR, ERROR, -9223372036854775807, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 6. nt_defs
    1, 2, ERROR, ERROR, ERROR, -1, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 7. token_defs
    1, 2, 3, 4, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 8. nt_def
    -7, -7, ERROR, ERROR, ERROR, -7, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 9. token_def
    -3, -3, -3, -3, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 10. "nt" IDENT
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 17, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 11. "goal" "nt"
    ERROR, ERROR, ERROR, ERROR, 18, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 12. "token" IDENT
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 19, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 13. "var" "token"
    ERROR, ERROR, ERROR, ERROR, 20, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 14. nt_defs nt_def
    -8, -8, ERROR, ERROR, ERROR, -8, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 15. token_defs nt_defs
    1, 2, ERROR, ERROR, ERROR, -2, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 16. token_defs token_def
    -4, -4, -4, -4, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 17. "nt" IDENT "{"
    ERROR, ERROR, ERROR, ERROR, 22, ERROR, ERROR, ERROR, 21, 23, ERROR, ERROR, ERROR,

    // 18. "goal" "nt" IDENT
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 29, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 19. "token" IDENT "="
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 30, ERROR, ERROR, ERROR,

    // 20. "var" "token" IDENT
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 31, ERROR, ERROR,

    // 21. "nt" IDENT "{" "}"
    -9, -9, ERROR, ERROR, ERROR, -9, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 22. "nt" IDENT "{" IDENT
    ERROR, ERROR, ERROR, ERROR, -21, ERROR, ERROR, ERROR, ERROR, -21, -21, -21, -21,

    // 23. "nt" IDENT "{" STR
    ERROR, ERROR, ERROR, ERROR, -22, ERROR, ERROR, ERROR, ERROR, -22, -22, -22, -22,

    // 24. "nt" IDENT "{" prods
    ERROR, ERROR, ERROR, ERROR, 22, ERROR, ERROR, ERROR, 32, 23, ERROR, ERROR, ERROR,

    // 25. "nt" IDENT "{" prod
    ERROR, ERROR, ERROR, ERROR, -13, ERROR, ERROR, ERROR, -13, -13, ERROR, ERROR, ERROR,

    // 26. "nt" IDENT "{" terms
    ERROR, ERROR, ERROR, ERROR, 22, ERROR, ERROR, ERROR, ERROR, 23, 34, ERROR, 35,

    // 27. "nt" IDENT "{" term
    ERROR, ERROR, ERROR, ERROR, -17, ERROR, ERROR, ERROR, ERROR, -17, -17, ERROR, -17,

    // 28. "nt" IDENT "{" symbol
    ERROR, ERROR, ERROR, ERROR, -19, ERROR, ERROR, ERROR, ERROR, -19, -19, 38, -19,

    // 29. "goal" "nt" IDENT "{"
    ERROR, ERROR, ERROR, ERROR, 22, ERROR, ERROR, ERROR, 39, 23, ERROR, ERROR, ERROR,

    // 30. "token" IDENT "=" STR
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 41, ERROR, ERROR,

    // 31. "var" "token" IDENT ";"
    -6, -6, -6, -6, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 32. "nt" IDENT "{" prods "}"
    -11, -11, ERROR, ERROR, ERROR, -11, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 33. "nt" IDENT "{" prods prod
    ERROR, ERROR, ERROR, ERROR, -14, ERROR, ERROR, ERROR, -14, -14, ERROR, ERROR, ERROR,

    // 34. "nt" IDENT "{" terms ";"
    ERROR, ERROR, ERROR, ERROR, -15, ERROR, ERROR, ERROR, -15, -15, ERROR, ERROR, ERROR,

    // 35. "nt" IDENT "{" terms "=>"
    ERROR, ERROR, ERROR, ERROR, 42, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 36. "nt" IDENT "{" terms action
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, 43, ERROR, ERROR,

    // 37. "nt" IDENT "{" terms term
    ERROR, ERROR, ERROR, ERROR, -18, ERROR, ERROR, ERROR, ERROR, -18, -18, ERROR, -18,

    // 38. "nt" IDENT "{" symbol "?"
    ERROR, ERROR, ERROR, ERROR, -20, ERROR, ERROR, ERROR, ERROR, -20, -20, ERROR, -20,

    // 39. "goal" "nt" IDENT "{" "}"
    -10, -10, ERROR, ERROR, ERROR, -10, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 40. "goal" "nt" IDENT "{" prods
    ERROR, ERROR, ERROR, ERROR, 22, ERROR, ERROR, ERROR, 44, 23, ERROR, ERROR, ERROR,

    // 41. "token" IDENT "=" STR ";"
    -5, -5, -5, -5, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,

    // 42. "nt" IDENT "{" terms "=>" IDENT
    ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, -23, ERROR, ERROR,

    // 43. "nt" IDENT "{" terms action ";"
    ERROR, ERROR, ERROR, ERROR, -16, ERROR, ERROR, ERROR, -16, -16, ERROR, ERROR, ERROR,

    // 44. "goal" "nt" IDENT "{" prods "}"
    -12, -12, ERROR, ERROR, ERROR, -12, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR,
];

pub trait Handler {
    type ReturnValue;
    // grammar ::= token_defs nt_defs
    fn grammar_p0(&mut self, a0: Option<Node<Self::ReturnValue>>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // token_defs ::= token_def
    fn token_defs_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // token_defs ::= token_defs token_def
    fn token_defs_p1(&mut self, a0: Node<Self::ReturnValue>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // token_def ::= "token" IDENT "=" STR ";"
    fn token_def_p0(&mut self, a0: Node<Self::ReturnValue>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // token_def ::= "var" "token" IDENT ";"
    fn token_def_p1(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // nt_defs ::= nt_def
    fn nt_defs_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // nt_defs ::= nt_defs nt_def
    fn nt_defs_p1(&mut self, a0: Node<Self::ReturnValue>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // nt_def ::= "goal" "nt" IDENT "{" prods "}"
    fn nt_def_p0(&mut self, a0: bool, a1: Node<Self::ReturnValue>, a2: Option<Node<Self::ReturnValue>>) -> Self::ReturnValue;
    // prods ::= prod
    fn prods_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // prods ::= prods prod
    fn prods_p1(&mut self, a0: Node<Self::ReturnValue>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // prod ::= terms action ";"
    fn prod_p0(&mut self, a0: Node<Self::ReturnValue>, a1: Option<Node<Self::ReturnValue>>) -> Self::ReturnValue;
    // terms ::= term
    fn terms_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // terms ::= terms term
    fn terms_p1(&mut self, a0: Node<Self::ReturnValue>, a1: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // term ::= symbol
    fn term_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // term ::= symbol "?"
    fn term_p1(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // symbol ::= IDENT
    fn symbol_p0(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // symbol ::= STR
    fn symbol_p1(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
    // action ::= "=>" IDENT
    fn action(&mut self, a0: Node<Self::ReturnValue>) -> Self::ReturnValue;
}

#[derive(Debug)]
pub enum NtNode {
    // grammar ::= token_defs nt_defs
    GrammarP0(Option<Node<NtNode>>, Node<NtNode>),
    // token_defs ::= token_def
    TokenDefsP0(Node<NtNode>),
    // token_defs ::= token_defs token_def
    TokenDefsP1(Node<NtNode>, Node<NtNode>),
    // token_def ::= "token" IDENT "=" STR ";"
    TokenDefP0(Node<NtNode>, Node<NtNode>),
    // token_def ::= "var" "token" IDENT ";"
    TokenDefP1(Node<NtNode>),
    // nt_defs ::= nt_def
    NtDefsP0(Node<NtNode>),
    // nt_defs ::= nt_defs nt_def
    NtDefsP1(Node<NtNode>, Node<NtNode>),
    // nt_def ::= "goal" "nt" IDENT "{" prods "}"
    NtDefP0(bool, Node<NtNode>, Option<Node<NtNode>>),
    // prods ::= prod
    ProdsP0(Node<NtNode>),
    // prods ::= prods prod
    ProdsP1(Node<NtNode>, Node<NtNode>),
    // prod ::= terms action ";"
    ProdP0(Node<NtNode>, Option<Node<NtNode>>),
    // terms ::= term
    TermsP0(Node<NtNode>),
    // terms ::= terms term
    TermsP1(Node<NtNode>, Node<NtNode>),
    // term ::= symbol
    TermP0(Node<NtNode>),
    // term ::= symbol "?"
    TermP1(Node<NtNode>),
    // symbol ::= IDENT
    SymbolP0(Node<NtNode>),
    // symbol ::= STR
    SymbolP1(Node<NtNode>),
    // action ::= "=>" IDENT
    Action(Node<NtNode>),
}

pub struct DefaultHandler {}

impl Handler for DefaultHandler {
    type ReturnValue = NtNode;
    fn grammar_p0(&mut self, a0: Option<Node<NtNode>>, a1: Node<NtNode>) -> NtNode {
        NtNode::GrammarP0(a0, a1)
    }
    fn token_defs_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::TokenDefsP0(a0)
    }
    fn token_defs_p1(&mut self, a0: Node<NtNode>, a1: Node<NtNode>) -> NtNode {
        NtNode::TokenDefsP1(a0, a1)
    }
    fn token_def_p0(&mut self, a0: Node<NtNode>, a1: Node<NtNode>) -> NtNode {
        NtNode::TokenDefP0(a0, a1)
    }
    fn token_def_p1(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::TokenDefP1(a0)
    }
    fn nt_defs_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::NtDefsP0(a0)
    }
    fn nt_defs_p1(&mut self, a0: Node<NtNode>, a1: Node<NtNode>) -> NtNode {
        NtNode::NtDefsP1(a0, a1)
    }
    fn nt_def_p0(&mut self, a0: bool, a1: Node<NtNode>, a2: Option<Node<NtNode>>) -> NtNode {
        NtNode::NtDefP0(a0, a1, a2)
    }
    fn prods_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::ProdsP0(a0)
    }
    fn prods_p1(&mut self, a0: Node<NtNode>, a1: Node<NtNode>) -> NtNode {
        NtNode::ProdsP1(a0, a1)
    }
    fn prod_p0(&mut self, a0: Node<NtNode>, a1: Option<Node<NtNode>>) -> NtNode {
        NtNode::ProdP0(a0, a1)
    }
    fn terms_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::TermsP0(a0)
    }
    fn terms_p1(&mut self, a0: Node<NtNode>, a1: Node<NtNode>) -> NtNode {
        NtNode::TermsP1(a0, a1)
    }
    fn term_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::TermP0(a0)
    }
    fn term_p1(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::TermP1(a0)
    }
    fn symbol_p0(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::SymbolP0(a0)
    }
    fn symbol_p1(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::SymbolP1(a0)
    }
    fn action(&mut self, a0: Node<NtNode>) -> NtNode {
        NtNode::Action(a0)
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum NonterminalId {
    Grammar = 0,
    NtDefs = 1,
    TokenDefs = 2,
    NtDef = 3,
    TokenDef = 4,
    Prods = 5,
    Prod = 6,
    Terms = 7,
    Term = 8,
    Symbol = 9,
    Action = 10,
}

static GOTO: [usize; 495] = [
    5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0,
    0, 15, 0, 8, 16, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 24, 25, 26, 27, 28, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 33, 26, 27, 28, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 37, 28, 36,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 40, 25, 26, 27, 28, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 33, 26, 27, 28, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
];

fn reduce<H: Handler>(handler: &mut H, prod: usize, stack: &mut Vec<Node<H::ReturnValue>>) -> NonterminalId {
    match prod {
        0 => {
            // grammar ::= nt_defs
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.grammar_p0(None, x0))));
            NonterminalId::Grammar
        }
        1 => {
            // grammar ::= token_defs nt_defs
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.grammar_p0(Some(x0), x1))));
            NonterminalId::Grammar
        }
        2 => {
            // token_defs ::= token_def
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.token_defs_p0(x0))));
            NonterminalId::TokenDefs
        }
        3 => {
            // token_defs ::= token_defs token_def
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.token_defs_p1(x0, x1))));
            NonterminalId::TokenDefs
        }
        4 => {
            // token_def ::= "token" IDENT "=" STR ";"
            stack.pop();
            let x1 = stack.pop().unwrap();
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.token_def_p0(x0, x1))));
            NonterminalId::TokenDef
        }
        5 => {
            // token_def ::= "var" "token" IDENT ";"
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.token_def_p1(x0))));
            NonterminalId::TokenDef
        }
        6 => {
            // nt_defs ::= nt_def
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.nt_defs_p0(x0))));
            NonterminalId::NtDefs
        }
        7 => {
            // nt_defs ::= nt_defs nt_def
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.nt_defs_p1(x0, x1))));
            NonterminalId::NtDefs
        }
        8 => {
            // nt_def ::= "nt" IDENT "{" "}"
            stack.pop();
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.nt_def_p0(false, x0, None))));
            NonterminalId::NtDef
        }
        9 => {
            // nt_def ::= "goal" "nt" IDENT "{" "}"
            stack.pop();
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.nt_def_p0(true, x0, None))));
            NonterminalId::NtDef
        }
        10 => {
            // nt_def ::= "nt" IDENT "{" prods "}"
            stack.pop();
            let x1 = stack.pop().unwrap();
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.nt_def_p0(false, x0, Some(x1)))));
            NonterminalId::NtDef
        }
        11 => {
            // nt_def ::= "goal" "nt" IDENT "{" prods "}"
            stack.pop();
            let x1 = stack.pop().unwrap();
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.nt_def_p0(true, x0, Some(x1)))));
            NonterminalId::NtDef
        }
        12 => {
            // prods ::= prod
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.prods_p0(x0))));
            NonterminalId::Prods
        }
        13 => {
            // prods ::= prods prod
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.prods_p1(x0, x1))));
            NonterminalId::Prods
        }
        14 => {
            // prod ::= terms ";"
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.prod_p0(x0, None))));
            NonterminalId::Prod
        }
        15 => {
            // prod ::= terms action ";"
            stack.pop();
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.prod_p0(x0, Some(x1)))));
            NonterminalId::Prod
        }
        16 => {
            // terms ::= term
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.terms_p0(x0))));
            NonterminalId::Terms
        }
        17 => {
            // terms ::= terms term
            let x1 = stack.pop().unwrap();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.terms_p1(x0, x1))));
            NonterminalId::Terms
        }
        18 => {
            // term ::= symbol
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.term_p0(x0))));
            NonterminalId::Term
        }
        19 => {
            // term ::= symbol "?"
            stack.pop();
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.term_p1(x0))));
            NonterminalId::Term
        }
        20 => {
            // symbol ::= IDENT
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.symbol_p0(x0))));
            NonterminalId::Symbol
        }
        21 => {
            // symbol ::= STR
            let x0 = stack.pop().unwrap();
            stack.push(Node::Nonterminal(Box::new(handler.symbol_p1(x0))));
            NonterminalId::Symbol
        }
        22 => {
            // action ::= "=>" IDENT
            let x0 = stack.pop().unwrap();
            stack.pop();
            stack.push(Node::Nonterminal(Box::new(handler.action(x0))));
            NonterminalId::Action
        }
        _ => panic!("no such production: {}", prod),
    }
}

static TABLES: ParserTables<'static> = ParserTables {
    state_count: 45,
    action_table: &ACTIONS,
    action_width: 13,
    goto_table: &GOTO,
    goto_width: 11,
};

pub fn parse_grammar<H: Handler, In: TokenStream<Token = Token>>(
    handler: &mut H,
    tokens: In,
) -> Result<Node<H::ReturnValue>, &'static str> {
    parser_runtime::parse(handler, tokens, 0, &TABLES, reduce)
}

